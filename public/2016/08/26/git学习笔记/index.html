<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="笔记 git," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="起步版本控制关于版本控制什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。">
<meta property="og:type" content="article">
<meta property="og:title" content="git学习笔记(一)">
<meta property="og:url" content="http://yoursite.com/2016/08/26/git学习笔记/index.html">
<meta property="og:site_name" content="CMeUp">
<meta property="og:description" content="起步版本控制关于版本控制什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。">
<meta property="og:updated_time" content="2016-10-31T03:55:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git学习笔记(一)">
<meta name="twitter:description" content="起步版本控制关于版本控制什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'TanZhiXuan'
    }
  };
</script>

  <title> git学习笔记(一) | CMeUp </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?93e7437418d71c769278ecc4f708b80a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">CMeUp</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Welcome to my blog, pleased to accept your remark.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                git学习笔记(一)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-26T23:25:51+08:00" content="2016-08-26">
              2016-08-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/26/git学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/26/git学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>关于版本控制<br>什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上，你可以对任何类型的文件进行版本控制。<br><a id="more"></a></p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。<br>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能）。采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h3><h4 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h4><p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容.Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>
<h4 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h4><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p>
<h4 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h4><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<h4 id="基本的-Git-工作流程如下："><a href="#基本的-Git-工作流程如下：" class="headerlink" title="基本的 Git 工作流程如下："></a>基本的 Git 工作流程如下：</h4><p>在工作目录中修改某些文件。<br>对修改后的文件进行快照，然后保存到暂存区域。<br>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h4><p>若是条件允许，从源代码安装有很多好处，至少可以安装最新的版本。Git 的每个版本都在不断尝试改进用户体验，所以能通过源代码自己编译安装最新版本就再好不过了。有些 Linux 版本自带的安装包更新起来并不及时，所以除非你在用最新的 distro 或者 backports，那么从源代码安装其实该算是最佳选择。Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在 Ubuntu 这类 Debian 体系的系统上可以用 apt-get 安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ apt-get install git</div></pre></td></tr></table></figure></p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在 Windows 上安装:<a href="http://msysgit.github.com/" target="_blank" rel="external">官网</a><br>给 Windows 用户的敬告：你应该在 msysGit 提供的 Unix 风格的 shell 来运行 Git。在 Unix 风格的 shell 中，可以使用本书中提及的复杂多行的命令。对于那些需要在 Windows 命令行中使用 Git 的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来（在 Linux 中是单引号）；另外，如果扬抑符（^）作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。因为扬抑符在 Windows 命令行中表示续行（译注：即下一行为这一行命令的继续）。</p>
<h3 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h3><p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。<br>Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>1, /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。<br>2, ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。<br>3, 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"John Doe"</span></div><div class="line">$ git config --global user.email johndoe@example.com</div></pre></td></tr></table></figure></p>
<p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4><p>接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global core.editor emacs</div></pre></td></tr></table></figure></p>
<h4 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h4><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global merge.tool vimdiff</div></pre></td></tr></table></figure></p>
<p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<h4 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h4><p>要检查已有的配置信息，可以使用 git config –list 命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --list</div><div class="line">user.name=Scott Chacon</div><div class="line">user.email=schacon@gmail.com</div><div class="line">color.status=auto</div><div class="line">color.branch=auto</div><div class="line">color.interactive=auto</div><div class="line">color.diff=auto</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</p>
<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config user.name</div><div class="line">Scott Chacon</div></pre></td></tr></table></figure></p>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，方法有三：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">help</span> &lt;verb&gt;</div><div class="line">$ git &lt;verb&gt; --help</div><div class="line">$ man git-&lt;verb&gt;</div></pre></td></tr></table></figure></p>
<p>我们随时都可以浏览这些帮助信息而无需连网。 不过，要是你觉得还不够，可以到 Freenode IRC 服务器（irc.freenode.net）上的 #git 或 #github 频道寻求他人帮助。这两个频道上总有着上百号人，大多都有着丰富的 Git 知识，并且乐于助人。</p>
<h2 id="Git基础-1"><a href="#Git基础-1" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="取得项目的-Git-仓库"><a href="#取得项目的-Git-仓库" class="headerlink" title="取得项目的 Git 仓库"></a>取得项目的 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。</p>
<h4 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h4><p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。（在第九章我们会详细说明刚才创建的 .git 目录中究竟有哪些文件，以及都起些什么作用。）<br>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add *.c</div><div class="line">$ git add README</div><div class="line">$ git commit -m <span class="string">'initial project version'</span></div></pre></td></tr></table></figure></p>
<h4 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h4><p>如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使用的是 clone 而不是 checkout。这是个非常重要的差别，Git 收取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有关细节请参考第四章）。</p>
<p>克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git</div></pre></td></tr></table></figure></p>
<p>这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</div></pre></td></tr></table></figure></p>
<p>唯一的差别就是，现在新建的目录成了 mygrit，其他的都和上边的一样。</p>
<p>Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s):// 或者 user@server:/path.git 表示的 SSH 传输协议。我们会在第四章详细介绍所有这些协议在服务器端该如何配置使用，以及各种方式之间的利弊。</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>现在我们手上已经有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。</p>
<h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要确定哪些文件当前处于什么状态，可以用 git status 命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure></p>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在的分支是 master，这是默认的分支名称，实际是可以修改的，现在先不用考虑。下一章我们就会详细讨论分支和引用。</p>
<p>现在让我们用 vim 创建一个新文件 README，保存退出后运行 git status 会看到该文件出现在未跟踪文件列表中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ vim README		<span class="comment">#自学vim编辑器</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        README</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</div></pre></td></tr></table></figure></p>
<p>在状态报告中可以看到新建的README文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   README</div></pre></td></tr></table></figure></p>
<p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）</p>
<h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>现在我们修改下之前已跟踪过的文件 benchmarks.rb，然后再次运行 status 命令，会看到这样的状态报告：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   README</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>文件 benchmarks.rb 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。现在让我们运行 git add 将 benchmarks.rb 放到暂存区，然后再看看 git status 的输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add benchmarks.rb</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   README</div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 benchmarks.rb 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 git status 看看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ vim benchmarks.rb</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   README</div><div class="line">        modified:   benchmarks.rb</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>怎么回事？ benchmarks.rb 文件出现了两次！一次算未暂存，一次算已暂存，这怎么可能呢？好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add benchmarks.rb</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   README</div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure></p>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 .gitignore 的格式规范如下：</p>
<p>1, 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br>2, 可以使用标准的 glob 模式匹配。<br>3, 匹配模式最后跟反斜杠（/）说明要忽略的是目录。<br>4, 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。<br>我们再看一个 .gitignore 文件的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></div><div class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></div><div class="line">*.a</div><div class="line"><span class="comment"># 但 lib.a 除外</span></div><div class="line">!lib.a</div><div class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></div><div class="line">/TODO</div><div class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></div><div class="line">build/</div><div class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></div><div class="line">doc/*.txt</div><div class="line"><span class="comment"># ignore all .txt files in the doc/ directory</span></div><div class="line">doc/**/*.txt</div></pre></td></tr></table></figure></p>
<p>A **/ pattern is available in Git since version 1.8.2.</p>
<h4 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h4><p>实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令。稍后我们会详细介绍 git diff，不过现在，它已经能回答我们的两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？ git diff 会使用文件补丁的格式显示具体添加和删除的行。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 benchmarks.rb 文件后先别暂存，运行 status 命令将会看到：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/benchmarks.rb b/benchmarks.rb</div><div class="line">index 3cb747f..da65585 100644</div><div class="line">--- a/benchmarks.rb</div><div class="line">+++ b/benchmarks.rb</div><div class="line">@@ -36,6 +36,10 @@ def main</div><div class="line">           @commit.parents[0].parents[0].parents[0]</div><div class="line">         end</div><div class="line"></div><div class="line">+        run_code(x, <span class="string">'commits 1'</span>) <span class="keyword">do</span></div><div class="line">+          git.commits.size</div><div class="line">+        end</div><div class="line">+</div><div class="line">         run_code(x, <span class="string">'commits 2'</span>) <span class="keyword">do</span></div><div class="line">           <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, 15)</div><div class="line">           log.size</div></pre></td></tr></table></figure></p>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）来看看实际的效果：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git diff --cached</div><div class="line">diff --git a/README b/README</div><div class="line">new file mode 100644</div><div class="line">index 0000000..03902a1</div><div class="line">--- /dev/null</div><div class="line">+++ b/README2</div><div class="line">@@ -0,0 +1,5 @@</div><div class="line">+grit</div><div class="line">+ by Tom Preston-Werner, Chris Wanstrath</div><div class="line">+ http://github.com/mojombo/grit</div><div class="line">+</div><div class="line">+Grit is a Ruby library <span class="keyword">for</span> extracting information from a Git repository</div></pre></td></tr></table></figure></p>
<p>像之前说的，暂存 benchmarks.rb 后再编辑，运行 git status 会看到暂存前后的两个版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add benchmarks.rb</div><div class="line">$ <span class="built_in">echo</span> <span class="string">'# test line'</span> &gt;&gt; benchmarks.rb</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>现在运行 git diff 看暂存前后的变化：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/benchmarks.rb b/benchmarks.rb</div><div class="line">index e445e28..86b2f7c 100644</div><div class="line">--- a/benchmarks.rb</div><div class="line">+++ b/benchmarks.rb</div><div class="line">@@ -127,3 +127,4 @@ end</div><div class="line"> main()</div><div class="line"></div><div class="line"> <span class="comment">##pp Grit::GitRuby.cache_client.stats</span></div><div class="line">+<span class="comment"># test line</span></div></pre></td></tr></table></figure></p>
<p>然后用 git diff –cached 查看已经暂存起来的变化：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git diff --cached</div><div class="line">diff --git a/benchmarks.rb b/benchmarks.rb</div><div class="line">index 3cb747f..e445e28 100644</div><div class="line">--- a/benchmarks.rb</div><div class="line">+++ b/benchmarks.rb</div><div class="line">@@ -36,6 +36,10 @@ def main</div><div class="line">          @commit.parents[0].parents[0].parents[0]</div><div class="line">        end</div><div class="line"></div><div class="line">+        run_code(x, <span class="string">'commits 1'</span>) <span class="keyword">do</span></div><div class="line">+          git.commits.size</div><div class="line">+        end</div><div class="line">+</div><div class="line">        run_code(x, <span class="string">'commits 2'</span>) <span class="keyword">do</span></div><div class="line">          <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, 15)</div><div class="line">          log.size</div></pre></td></tr></table></figure></p>
<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git commit</div></pre></td></tr></table></figure></p>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 git config –global core.editor 命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Please enter the commit message for your changes. Lines starting</span></div><div class="line"><span class="comment"># with '#' will be ignored, and an empty message aborts the commit.</span></div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changes to be committed:</span></div><div class="line"><span class="comment">#       new file:   README</span></div><div class="line"><span class="comment">#       modified:   benchmarks.rb</span></div><div class="line"><span class="comment">#</span></div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line"><span class="string">".git/COMMIT_EDITMSG"</span> 10L, 283C</div></pre></td></tr></table></figure></p>
<p>可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 -v 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>
<p>另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git commit -m <span class="string">"Story 182: Fix benchmarks for speed"</span></div><div class="line">[master 463dc4f] Story 182: Fix benchmarks <span class="keyword">for</span> speed</div><div class="line"> 2 files changed, 3 insertions(+)</div><div class="line"> create mode 100644 README</div></pre></td></tr></table></figure></p>
<p>好，现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p>
<p>记住，提交时的记录是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div><div class="line">$ git commit <span class="_">-a</span> -m <span class="string">'added new benchmarks'</span></div><div class="line">[master 83e38c7] added new benchmarks</div><div class="line"> 1 files changed, 5 insertions(+)</div></pre></td></tr></table></figure></p>
<p>看到了吗？提交之前不再需要 git add 文件 benchmarks.rb 了。</p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是未暂存清单）看到：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ rm grit.gemspec</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        deleted:    grit.gemspec</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure></p>
<p>然后再运行 git rm 记录此次移除文件的操作：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rm grit.gemspec</div><div class="line">rm <span class="string">'grit.gemspec'</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        deleted:    grit.gemspec</div></pre></td></tr></table></figure></p>
<p>最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rm --cached readme.txt</div></pre></td></tr></table></figure></p>
<p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rm <span class="built_in">log</span>/\*.log</div></pre></td></tr></table></figure></p>
<p>注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log 的文件。类似的比如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git rm \*~</div></pre></td></tr></table></figure></p>
<p>会递归删除当前目录及其子目录中所有 ~ 结尾的文件。</p>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure></p>
<p>它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git mv README.txt README</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        renamed:    README.txt -&gt; README</div></pre></td></tr></table></figure></p>
<p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ mv README.txt README</div><div class="line">$ git rm README.txt</div><div class="line">$ git add README</div></pre></td></tr></table></figure></p>
<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 git log 命令查看。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，运行下面的命令获取该项目源代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git <span class="built_in">clone</span> git://github.com/schacon/simplegit-progit.git</div></pre></td></tr></table></figure></p>
<p>然后在此项目中运行 git log，应该会看到下面的输出：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span></div><div class="line">commit ca82a6dff817ec66f44342007202690a93763949</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</div><div class="line"></div><div class="line">    changed the version number</div><div class="line"></div><div class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</div><div class="line"></div><div class="line">    removed unnecessary <span class="built_in">test</span> code</div><div class="line"></div><div class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</div><div class="line"></div><div class="line">    first commit</div></pre></td></tr></table></figure></p>
<p>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<p>git log 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
<p>我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> -p -2</div><div class="line">commit ca82a6dff817ec66f44342007202690a93763949</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</div><div class="line"></div><div class="line">    changed the version number</div><div class="line"></div><div class="line">diff --git a/Rakefile b/Rakefile</div><div class="line">index a874b73..8f94139 100644</div><div class="line">--- a/Rakefile</div><div class="line">+++ b/Rakefile</div><div class="line">@@ -5,5 +5,5 @@ require <span class="string">'rake/gempackagetask'</span></div><div class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</div><div class="line">     s.name      =   <span class="string">"simplegit"</span></div><div class="line">-    s.version   =   <span class="string">"0.1.0"</span></div><div class="line">+    s.version   =   <span class="string">"0.1.1"</span></div><div class="line">     s.author    =   <span class="string">"Scott Chacon"</span></div><div class="line">     s.email     =   <span class="string">"schacon@gee-mail.com</span></div><div class="line"></div><div class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</div><div class="line"></div><div class="line">    removed unnecessary test code</div><div class="line"></div><div class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</div><div class="line">index a0a60ae..47c6340 100644</div><div class="line">--- a/lib/simplegit.rb</div><div class="line">+++ b/lib/simplegit.rb</div><div class="line">@@ -18,8 +18,3 @@ class SimpleGit</div><div class="line">     end</div><div class="line"></div><div class="line"> end</div><div class="line">-</div><div class="line">-if <span class="variable">$0</span> == __FILE__</div><div class="line">-  git = SimpleGit.new</div><div class="line">-  puts git.show</div><div class="line">-end</div><div class="line">\ No newline at end of file</div></pre></td></tr></table></figure></p>
<p>该选项除了显示基本信息之外，还在附带了每次 commit 的变化。当进行代码审查，或者快速浏览某个搭档提交的 commit 的变化的时候，这个参数就非常有用了。</p>
<p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 –word-diff 选项。我们可以将其添加到 git log -p 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。下面是一个简单的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> -U1 --word-diff</div><div class="line">commit ca82a6dff817ec66f44342007202690a93763949</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</div><div class="line"></div><div class="line">    changed the version number</div><div class="line"></div><div class="line">diff --git a/Rakefile b/Rakefile</div><div class="line">index a874b73..8f94139 100644</div><div class="line">--- a/Rakefile</div><div class="line">+++ b/Rakefile</div><div class="line">@@ -7,3 +7,3 @@ spec = Gem::Specification.new <span class="keyword">do</span> |s|</div><div class="line">    s.name      =   <span class="string">"simplegit"</span></div><div class="line">    s.version   =   [-<span class="string">"0.1.0"</span>-]&#123;+<span class="string">"0.1.1"</span>+&#125;</div><div class="line">    s.author    =   <span class="string">"Scott Chacon"</span></div></pre></td></tr></table></figure></p>
<p>如你所见，这里并没有平常看到的添加行或者删除行的信息。这里的对比显示在行间。新增加的单词被 {+ +} 括起来，被删除的单词被 [- -] 括起来。在进行单词层面的对比的时候，你可能希望上下文（ context ）行数从默认的 3 行，减为 1 行，那么可以使用 -U1 选项。上面的例子中，我们就使用了这个选项。</p>
<p>另外，git log 还提供了许多摘要选项可以用，比如 –stat，仅显示简要的增改行数统计：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --stat</div><div class="line">commit ca82a6dff817ec66f44342007202690a93763949</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</div><div class="line"></div><div class="line">    changed the version number</div><div class="line"></div><div class="line"> Rakefile |    2 +-</div><div class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</div><div class="line"></div><div class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</div><div class="line"></div><div class="line">    removed unnecessary <span class="built_in">test</span> code</div><div class="line"></div><div class="line"> lib/simplegit.rb |    5 -----</div><div class="line"> 1 file changed, 5 deletions(-)</div><div class="line"></div><div class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</div><div class="line"></div><div class="line">    first commit</div><div class="line"></div><div class="line"> README           |    6 ++++++</div><div class="line"> Rakefile         |   23 +++++++++++++++++++++++</div><div class="line"> lib/simplegit.rb |   25 +++++++++++++++++++++++++</div><div class="line"> 3 files changed, 54 insertions(+)</div></pre></td></tr></table></figure></p>
<p>每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。 还有个常用的 –pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=oneline</div><div class="line">ca82a6dff817ec66f44342007202690a93763949 changed the version number</div><div class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="built_in">test</span> code</div><div class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</div></pre></td></tr></table></figure></p>
<p>但最有意思的是 format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></div><div class="line">ca82a6d - Scott Chacon, 11 months ago : changed the version number</div><div class="line">085bb3b - Scott Chacon, 11 months ago : removed unnecessary <span class="built_in">test</span> code</div><div class="line">a11bef0 - Scott Chacon, 11 months ago : first commit</div></pre></td></tr></table></figure></p>
<p>表 2-1 列出了常用的格式占位符写法及其代表的意义。</p>
<!-- Attention to translators: this is a table declaration. The lines must be formatted as follows <TAB><First column text><TAB><Second column text> -->
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">选项	 说明</div><div class="line">%H	提交对象（commit）的完整哈希字串</div><div class="line">%h	提交对象的简短哈希字串</div><div class="line">%T	树对象（tree）的完整哈希字串</div><div class="line">%t	树对象的简短哈希字串</div><div class="line">%P	父对象（parent）的完整哈希字串</div><div class="line">%p	父对象的简短哈希字串</div><div class="line">%an	作者（author）的名字</div><div class="line">%ae	作者的电子邮件地址</div><div class="line">%ad	作者修订日期（可以用 -date= 选项定制格式）</div><div class="line">%ar	作者修订日期，按多久以前的方式显示</div><div class="line">%cn	提交者(committer)的名字</div><div class="line">%ce	提交者的电子邮件地址</div><div class="line">%<span class="built_in">cd</span>	提交日期</div><div class="line">%cr	提交日期，按多久以前的方式显示</div><div class="line">%s	提交说明</div></pre></td></tr></table></figure>
<p>你一定奇怪作者（author）和提交者（committer）之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。我们会在第五章再详细介绍两者之间的细微差别。</p>
<p>用 oneline 或 format 时结合 –graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。在我们之前提到的 Grit 项目仓库中可以看到：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h %s"</span> --graph</div><div class="line">* 2d3acf9 ignore errors from SIGCHLD on <span class="built_in">trap</span></div><div class="line">*  5e3ee11 Merge branch <span class="string">'master'</span> of git://github.com/dustin/grit</div><div class="line">|\</div><div class="line">| * 420eac9 Added a method <span class="keyword">for</span> getting the current branch.</div><div class="line">* | 30e367c timeout code and tests</div><div class="line">* | 5a09431 add timeout protection to grit</div><div class="line">* | e1193f8 support <span class="keyword">for</span> heads with slashes <span class="keyword">in</span> them</div><div class="line">|/</div><div class="line">* d6016bc require time <span class="keyword">for</span> xmlschema</div><div class="line">*  11d191e Merge branch <span class="string">'defunkt'</span> into <span class="built_in">local</span></div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">选项	说明</div><div class="line">-p	按补丁格式显示每个更新之间的差异。</div><div class="line">--word-diff	按 word diff 格式显示差异。</div><div class="line">--stat	显示每次更新的文件修改统计信息。</div><div class="line">--shortstat	只显示 --stat 中最后的行数修改添加移除统计。</div><div class="line">--name-only	仅在提交信息后显示已修改的文件清单。</div><div class="line">--name-status	显示新增、修改、删除的文件清单。</div><div class="line">--abbrev-commit	仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</div><div class="line">--relative-date	使用较短的相对时间显示（比如，“2 weeks ago”）。</div><div class="line">--graph	显示 ASCII 图形表示的分支合并历史。</div><div class="line">--pretty	使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</div><div class="line">--oneline	`--pretty=oneline --abbrev-commit` 的简化用法。</div></pre></td></tr></table></figure>
<h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p>除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前我们已经看到过 -2 了，它只显示最近的两条提交，实际上，这是 -<n> 选项的写法，其中的 n 可以是任何自然数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序（less），要看更早的更新只需翻到下页即可。</n></p>
<p>另外还有按照时间作限制的选项，比如 –since 和 –until。下面的命令列出所有最近两周内的提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --since=2.weeks</div></pre></td></tr></table></figure></p>
<p>你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。</p>
<p>还可以给出若干搜索条件，列出符合的提交。用 –author 选项显示指定作者的提交，用 –grep 选项搜索提交说明中的关键字。（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 –all-match 选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个真正实用的git log选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<p>表 2-3 还列出了其他常用的类似选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">选项	说明</div><div class="line">-(n)	仅显示最近的 n 条提交</div><div class="line">--since, --after	仅显示指定时间之后的提交。</div><div class="line">--until, --before	仅显示指定时间之前的提交。</div><div class="line">--author	仅显示指定作者相关的提交。</div><div class="line">--committer	仅显示指定提交者相关的提交。</div></pre></td></tr></table></figure>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=<span class="string">"%h - %s"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \</div><div class="line">   --before=<span class="string">"2008-11-01"</span> --no-merges -- t/</div><div class="line">5610e3b - Fix testcase failure when extended attribute</div><div class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;()</div><div class="line">f563754 - demonstrate breakage of detached checkout wi</div><div class="line">d1a43f2 - reset --hard/<span class="built_in">read</span>-tree --reset -u: remove un</div><div class="line">51a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detac</div><div class="line">b0ad11e - pull: allow <span class="string">"git pull origin <span class="variable">$something</span>:<span class="variable">$cur</span></span></div></pre></td></tr></table></figure></p>
<p>Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。</p>
<p>####使用图形化工具查阅提交历史</p>
<p>有时候图形化工具更容易展示历史提交的变化，随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 git log 命令的可视化版本，凡是 git log 可以用的选项也都能用在 gitk 上。在项目工作目录中输入 gitk 命令后，就会启动图 2-2 所示的界面<br>上半个窗口显示的是历次提交的分支祖先图谱，下半个窗口显示当前点选的提交对应的具体差异。</p>
<h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><p>任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。</p>
<h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 –amend 选项重新提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p>
<p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p>
<p>启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。</p>
<p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git commit -m <span class="string">'initial commit'</span></div><div class="line">$ git add forgotten_file</div><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<h4 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h4><p>接下来的两个小节将演示如何取消暂存区域中的文件，以及如何取消工作目录中已修改的文件。不用担心，查看文件状态的时候就提示了该如何撤消，所以不需要死记硬背。来看下面的例子，有两个修改过的文件，我们想要分开提交，但不小心用 git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？其实，git status 的命令输出已经告诉了我们该怎么做：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   README.txt</div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>就在 “Changes to be committed” 下面，括号中有提示，可以使用 git reset HEAD <file>… 的方式取消暂存。好吧，我们来试试取消暂存 benchmarks.rb 文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git reset HEAD benchmarks.rb</div><div class="line">Unstaged changes after reset:</div><div class="line">M       benchmarks.rb</div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   README.txt</div><div class="line"></div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></file></p>
<p>这条命令看起来有些古怪，先别管，能用就行。现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态。</p>
<h4 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h4><p>如果觉得刚才对 benchmarks.rb 的修改完全没有必要，该如何取消修改，回到之前的状态（也就是修改之前的版本）呢？git status 同样提示了具体的撤消方法，接着上面的例子，现在未暂存区域看起来像这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   benchmarks.rb</div></pre></td></tr></table></figure></p>
<p>在第二个括号中，我们看到了抛弃文件修改的命令（至少在 Git 1.6.1 以及更高版本中会这样提示，如果你还在用老版本，我们强烈建议你升级，以获取最佳的用户体验），让我们试试看：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git checkout -- benchmarks.rb 		<span class="comment">#必须是跟踪的</span></div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   README.txt</div></pre></td></tr></table></figure></p>
<p>可以看到，该文件已经恢复到修改前的版本。你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。</p>
<p>记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p>要参与任何一个 Git 项目的协作，必须要了解该如何管理远程仓库。远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。 管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。本节我们将详细讨论远程库的管理和使用。</p>
<h4 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h4><p>要查看当前配置有哪些远程仓库，可以用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/ticgit.git</div><div class="line">Cloning into <span class="string">'ticgit'</span>...</div><div class="line">remote: Reusing existing pack: 1857, done.</div><div class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</div><div class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 193.00 KiB/s, done.</div><div class="line">Resolving deltas: 100% (772/772), done.</div><div class="line">Checking connectivity... done.</div><div class="line">$ <span class="built_in">cd</span> ticgit</div><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<p>也可以加上 -v 选项（译注：此为 –verbose 的简写，取首字母），显示对应的克隆地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin  git://github.com/schacon/ticgit.git (fetch)</div><div class="line">origin  git://github.com/schacon/ticgit.git (push)</div></pre></td></tr></table></figure></p>
<p>如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> grit</div><div class="line">$ git remote -v</div><div class="line">bakkdoor  git://github.com/bakkdoor/grit.git</div><div class="line">cho45     git://github.com/cho45/grit.git</div><div class="line">defunkt   git://github.com/defunkt/grit.git</div><div class="line">koke      git://github.com/koke/grit.git</div><div class="line">origin    git@github.com:mojombo/grit.git</div></pre></td></tr></table></figure></p>
<p>这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。请注意，上面列出的地址只有 origin 用的是 SSH URL 链接，所以也只有这个仓库我能推送数据上去（我们会在第四章解释原因）。</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote</div><div class="line">origin</div><div class="line">$ git remote add pb git://github.com/paulboone/ticgit.git</div><div class="line">$ git remote -v</div><div class="line">origin	git://github.com/schacon/ticgit.git</div><div class="line">pb	git://github.com/paulboone/ticgit.git</div></pre></td></tr></table></figure></p>
<p>现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git fetch pb</div><div class="line">remote: Counting objects: 58, done.</div><div class="line">remote: Compressing objects: 100% (41/41), done.</div><div class="line">remote: Total 44 (delta 24), reused 1 (delta 0)</div><div class="line">Unpacking objects: 100% (44/44), done.</div><div class="line">From git://github.com/paulboone/ticgit</div><div class="line"> * [new branch]      master     -&gt; pb/master</div><div class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</div></pre></td></tr></table></figure></p>
<h4 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h4><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git fetch [remote-name]</div></pre></td></tr></table></figure></p>
<p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。（我们会在第三章详细讨论关于分支的概念和操作。）</p>
<p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，git fetch origin 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p>
<p>如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 git pull，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<h4 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h4><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： git push [remote-name] [branch-name]。如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure></p>
<p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。有关推送数据到远程仓库的详细内容见第三章。</p>
<h4 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h4><p>我们可以通过命令 git remote show [remote-name] 查看某个远程仓库的详细信息，比如要看所克隆的 origin 仓库，可以运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote show origin</div><div class="line">* remote origin</div><div class="line">  URL: git://github.com/schacon/ticgit.git</div><div class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch master</div><div class="line">    master</div><div class="line">  Tracked remote branches</div><div class="line">    master</div><div class="line">    ticgit</div></pre></td></tr></table></figure></p>
<p>除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 git pull 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。</p>
<p>上面的例子非常简单，而随着使用 Git 的深入，git remote show 给出的信息可能会像这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote show origin</div><div class="line">* remote origin</div><div class="line">  URL: git@github.com:defunkt/github.git</div><div class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch issues</div><div class="line">    issues</div><div class="line">  Remote branch merged with <span class="string">'git pull'</span> <span class="keyword">while</span> on branch master</div><div class="line">    master</div><div class="line">  New remote branches (next fetch will store <span class="keyword">in</span> remotes/origin)</div><div class="line">    caching</div><div class="line">  Stale tracking branches (use <span class="string">'git remote prune'</span>)</div><div class="line">    libwalker</div><div class="line">    walker2</div><div class="line">  Tracked remote branches</div><div class="line">    acl</div><div class="line">    apiv2</div><div class="line">    dashboard2</div><div class="line">    issues</div><div class="line">    master</div><div class="line">    postgres</div><div class="line">  Local branch pushed with <span class="string">'git push'</span></div><div class="line">    master:master</div></pre></td></tr></table></figure></p>
<h4 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h4><p>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成 paul，可以这么运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote rename pb paul</div><div class="line">$ git remote</div><div class="line">origin</div><div class="line">paul</div></pre></td></tr></table></figure></p>
<p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master。</p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git remote rm paul</div><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure></p>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。</p>
<h4 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h4><p>列出现有标签的命令非常简单，直接运行 git tag 即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.1</div><div class="line">v1.3</div></pre></td></tr></table></figure></p>
<p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p>
<p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag <span class="_">-l</span> <span class="string">'v1.4.2.*'</span></div><div class="line">v1.4.2.1</div><div class="line">v1.4.2.2</div><div class="line">v1.4.2.3</div><div class="line">v1.4.2.4</div></pre></td></tr></table></figure></p>
<h4 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h4><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<h4 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h4><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag <span class="_">-a</span> v1.4 -m <span class="string">'my version 1.4'</span></div><div class="line">$ git tag</div><div class="line">v0.1</div><div class="line">v1.3</div><div class="line">v1.4</div></pre></td></tr></table></figure></p>
<p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<p>可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p>
<h4 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h4><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可:<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag <span class="_">-s</span> v1.5 -m <span class="string">'my signed 1.5 tag'</span></div><div class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></div><div class="line">user: <span class="string">"Scott Chacon &lt;schacon@gee-mail.com&gt;"</span></div><div class="line">1024-bit DSA key, ID F721C45A, created 2009-02-09</div></pre></td></tr></table></figure></p>
<p>现在再运行 git show 会看到对应的 GPG 签名也附在其内：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git show v1.5</div><div class="line">tag v1.5</div><div class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Feb 9 15:22:20 2009 -0800</div><div class="line"></div><div class="line">my signed 1.5 tag</div><div class="line">-----BEGIN PGP SIGNATURE-----</div><div class="line">Version: GnuPG v1.4.8 (Darwin)</div><div class="line"></div><div class="line">iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</div><div class="line">Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</div><div class="line">=WryJ</div><div class="line">-----END PGP SIGNATURE-----</div><div class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</div><div class="line">Merge: 4a447f7... a6b4c97...</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</div><div class="line"></div><div class="line">    Merge branch <span class="string">'experiment'</span></div></pre></td></tr></table></figure></p>
<p>现在再运行 git show 会看到对应的 GPG 签名也附在其内：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git show v1.5</div><div class="line">tag v1.5</div><div class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Feb 9 15:22:20 2009 -0800</div><div class="line"></div><div class="line">my signed 1.5 tag</div><div class="line">-----BEGIN PGP SIGNATURE-----</div><div class="line">Version: GnuPG v1.4.8 (Darwin)</div><div class="line"></div><div class="line">iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN</div><div class="line">Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/</div><div class="line">=WryJ</div><div class="line">-----END PGP SIGNATURE-----</div><div class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</div><div class="line">Merge: 4a447f7... a6b4c97...</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</div><div class="line"></div><div class="line">    Merge branch <span class="string">'experiment'</span></div></pre></td></tr></table></figure></p>
<p>稍后我们再学习如何验证已经签署的标签。</p>
<h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag v1.4-lw</div><div class="line">$ git tag</div><div class="line">v0.1</div><div class="line">v1.3</div><div class="line">v1.4</div><div class="line">v1.4-lw</div><div class="line">v1.5</div></pre></td></tr></table></figure></p>
<p>现在运行 git show 查看此标签信息，就只有相应的提交对象摘要：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git show v1.4-lw</div><div class="line">commit 15027957951b64cf874c3557a0f3547bd83b3ff6</div><div class="line">Merge: 4a447f7... a6b4c97...</div><div class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Sun Feb 8 19:02:46 2009 -0800</div><div class="line"></div><div class="line">    Merge branch <span class="string">'experiment'</span></div></pre></td></tr></table></figure></p>
<h4 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h4><p>可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag -v v1.4.2.1</div><div class="line">object 883653babd8ee7ea23e6a5c392bb739348b1eb61</div><div class="line"><span class="built_in">type</span> commit</div><div class="line">tag v1.4.2.1</div><div class="line">tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700</div><div class="line"></div><div class="line">GIT 1.4.2.1</div><div class="line"></div><div class="line">Minor fixes since 1.4.2, including git-mv and git-http with alternates.</div><div class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</div><div class="line">gpg: Good signature from <span class="string">"Junio C Hamano &lt;junkio@cox.net&gt;"</span></div><div class="line">gpg:                 aka <span class="string">"[jpeg image of size 1513]"</span></div><div class="line">Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</div></pre></td></tr></table></figure></p>
<p>若是没有签署者的公钥，会报告类似下面这样的错误：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</div><div class="line">gpg: Can<span class="string">'t check signature: public key not found</span></div><div class="line">error: could not verify the tag 'v1.4.2.1<span class="string">'</span></div></pre></td></tr></table></figure></p>
<h4 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h4><p>你甚至可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --pretty=oneline</div><div class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="string">'experiment'</span></div><div class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</div><div class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</div><div class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="string">'experiment'</span></div><div class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit <span class="keyword">function</span></div><div class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</div><div class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</div><div class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</div><div class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</div><div class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</div></pre></td></tr></table></figure></p>
<p>我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag <span class="_">-a</span> v1.2 9fceb02</div></pre></td></tr></table></figure></p>
<p>可以看到我们已经补上了标签：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.1</div><div class="line">v1.2</div><div class="line">v1.3</div><div class="line">v1.4</div><div class="line">v1.4-lw</div><div class="line">v1.5</div><div class="line"></div><div class="line">$ git show v1.2</div><div class="line">tag v1.2</div><div class="line">Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;</div><div class="line">Date:   Mon Feb 9 15:32:16 2009 -0800</div><div class="line"></div><div class="line">version 1.2</div><div class="line">commit 9fceb02d0ae598e95dc970b74767f19372d61af8</div><div class="line">Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;</div><div class="line">Date:   Sun Apr 27 20:43:35 2008 -0700</div><div class="line"></div><div class="line">    updated rakefile</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h4><p>默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git push origin v1.5</div><div class="line">Counting objects: 50, done.</div><div class="line">Compressing objects: 100% (38/38), done.</div><div class="line">Writing objects: 100% (44/44), 4.56 KiB, done.</div><div class="line">Total 44 (delta 18), reused 8 (delta 1)</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line">* [new tag]         v1.5 -&gt; v1.5</div></pre></td></tr></table></figure></p>
<p>如果要一次推送所有本地新增的标签上去，可以使用 –tags 选项：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git push origin --tags</div><div class="line">Counting objects: 50, done.</div><div class="line">Compressing objects: 100% (38/38), done.</div><div class="line">Writing objects: 100% (44/44), 4.56 KiB, done.</div><div class="line">Total 44 (delta 18), reused 8 (delta 1)</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line"> * [new tag]         v0.1 -&gt; v0.1</div><div class="line"> * [new tag]         v1.2 -&gt; v1.2</div><div class="line"> * [new tag]         v1.4 -&gt; v1.4</div><div class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</div><div class="line"> * [new tag]         v1.5 -&gt; v1.5</div></pre></td></tr></table></figure></p>
<p>现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</p>
<h3 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h3><p>在结束本章之前，我还想和大家分享一些 Git 使用的技巧和窍门。很多使用 Git 的开发者可能根本就没用过这些技巧，我们也不是说在读过本书后非得用这些技巧不可，但至少应该有所了解吧。说实话，有了这些小窍门，我们的工作可以变得更简单，更轻松，更高效。</p>
<h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p>如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash），并把下面一行内容添加到你的 .bashrc 文件中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">source</span> ~/.git-completion.bash</div></pre></td></tr></table></figure></p>
<p>也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 /opt/local/etc/bash_completion.d 目录中，Linux 上则复制到 /etc/bash_completion.d/ 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。</p>
<p>如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动补全脚本，可以直接使用。</p>
<p>在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git co&lt;tab&gt;&lt;tab&gt;</div><div class="line">commit config</div></pre></td></tr></table></figure></p>
<p>此例中，键入 git co 然后连按两次 Tab 键，会看到两个相关的建议（命令） commit 和 config。继而输入 m<tab> 会自动完成 git commit 命令的输入。</tab></p>
<p>命令的选项也可以用这种方式自动完成，其实这种情况更实用些。比如运行 git log 的时候忘了相关选项的名字，可以输入开头的几个字母，然后敲 Tab 键看看有哪些匹配的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> -<span class="_">-s</span>&lt;tab&gt;</div><div class="line">--shortstat  --since=  --src-prefix=  --stat   --summary</div></pre></td></tr></table></figure></p>
<p>这个技巧不错吧，可以节省很多输入和查阅文档的时间。</p>
<h4 id="Git-命令别名"><a href="#Git-命令别名" class="headerlink" title="Git 命令别名"></a>Git 命令别名</h4><p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 git config 为命令设置别名。来看看下面的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global alias.co checkout</div><div class="line">$ git config --global alias.br branch</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure></p>
<p>现在，如果要输入 git commit 只需键入 git ci 即可。而随着 Git 使用的深入，会有很多经常要用到的命令，遇到这种情况，不妨建个别名提高效率。</p>
<p>使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global alias.unstage <span class="string">'reset HEAD --'</span></div></pre></td></tr></table></figure></p>
<p>这样一来，下面的两条命令完全等同：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git unstage fileA</div><div class="line">$ git reset HEAD fileA</div></pre></td></tr></table></figure></p>
<p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 last 命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global alias.last <span class="string">'log -1 HEAD'</span></div></pre></td></tr></table></figure></p>
<p>然后要看最后一次的提交信息，就变得简单多了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git last</div><div class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</div><div class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</div><div class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</div><div class="line"></div><div class="line">    <span class="built_in">test</span> <span class="keyword">for</span> current head</div><div class="line"></div><div class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</div></pre></td></tr></table></figure></p>
<p>可以看出，实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的子命令，这个好办，只需要在命令前加上 ! 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 git visual 启动 gitk：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git config --global alias.visual <span class="string">'!gitk'</span></div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记-git/" rel="tag">#笔记 git</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/26/制作hexo静态网页详细步骤/" rel="next" title="制作hexo静态网页详细步骤">
                <i class="fa fa-chevron-left"></i> 制作hexo静态网页详细步骤
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/27/Git学习笔记-二/" rel="prev" title="Git学习笔记(二)">
                Git学习笔记(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/26/git学习笔记/"
           data-title="git学习笔记(一)" data-url="http://yoursite.com/2016/08/26/git学习笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tzx" />
          <p class="site-author-name" itemprop="name">Tzx</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#起步"><span class="nav-number">1.</span> <span class="nav-text">起步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#版本控制"><span class="nav-number">1.1.</span> <span class="nav-text">版本控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式版本控制系统"><span class="nav-number">1.2.</span> <span class="nav-text">分布式版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git基础"><span class="nav-number">1.3.</span> <span class="nav-text">Git基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#直接记录快照，而非差异比较"><span class="nav-number">1.3.1.</span> <span class="nav-text">直接记录快照，而非差异比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#近乎所有操作都是本地执行"><span class="nav-number">1.3.2.</span> <span class="nav-text">近乎所有操作都是本地执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的三种状态"><span class="nav-number">1.3.3.</span> <span class="nav-text">文件的三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的-Git-工作流程如下："><span class="nav-number">1.3.4.</span> <span class="nav-text">基本的 Git 工作流程如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装"><span class="nav-number">1.4.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从源代码安装"><span class="nav-number">1.4.1.</span> <span class="nav-text">从源代码安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">1.4.2.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows"><span class="nav-number">1.4.3.</span> <span class="nav-text">Windows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初次运行-Git-前的配置"><span class="nav-number">1.5.</span> <span class="nav-text">初次运行 Git 前的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户信息"><span class="nav-number">1.5.1.</span> <span class="nav-text">用户信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文本编辑器"><span class="nav-number">1.5.2.</span> <span class="nav-text">文本编辑器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#差异分析工具"><span class="nav-number">1.5.3.</span> <span class="nav-text">差异分析工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看配置信息"><span class="nav-number">1.5.4.</span> <span class="nav-text">查看配置信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取帮助"><span class="nav-number">1.6.</span> <span class="nav-text">获取帮助</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git基础-1"><span class="nav-number">2.</span> <span class="nav-text">Git基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#取得项目的-Git-仓库"><span class="nav-number">2.1.</span> <span class="nav-text">取得项目的 Git 仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在工作目录中初始化新仓库"><span class="nav-number">2.1.1.</span> <span class="nav-text">在工作目录中初始化新仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从现有仓库克隆"><span class="nav-number">2.1.2.</span> <span class="nav-text">从现有仓库克隆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录每次更新到仓库"><span class="nav-number">2.2.</span> <span class="nav-text">记录每次更新到仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查当前文件状态"><span class="nav-number">2.2.1.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跟踪新文件"><span class="nav-number">2.2.2.</span> <span class="nav-text">跟踪新文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#暂存已修改文件"><span class="nav-number">2.2.3.</span> <span class="nav-text">暂存已修改文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略某些文件"><span class="nav-number">2.2.4.</span> <span class="nav-text">忽略某些文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看已暂存和未暂存的更新"><span class="nav-number">2.2.5.</span> <span class="nav-text">查看已暂存和未暂存的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提交更新"><span class="nav-number">2.2.6.</span> <span class="nav-text">提交更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳过使用暂存区域"><span class="nav-number">2.3.</span> <span class="nav-text">跳过使用暂存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移除文件"><span class="nav-number">2.3.1.</span> <span class="nav-text">移除文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动文件"><span class="nav-number">2.3.2.</span> <span class="nav-text">移动文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看提交历史"><span class="nav-number">2.3.3.</span> <span class="nav-text">查看提交历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限制输出长度"><span class="nav-number">2.3.4.</span> <span class="nav-text">限制输出长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#撤消操作"><span class="nav-number">2.4.</span> <span class="nav-text">撤消操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改最后一次提交"><span class="nav-number">2.4.1.</span> <span class="nav-text">修改最后一次提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取消已经暂存的文件"><span class="nav-number">2.4.2.</span> <span class="nav-text">取消已经暂存的文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取消对文件的修改"><span class="nav-number">2.4.3.</span> <span class="nav-text">取消对文件的修改</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程仓库的使用"><span class="nav-number">2.5.</span> <span class="nav-text">远程仓库的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看当前的远程库"><span class="nav-number">2.5.1.</span> <span class="nav-text">查看当前的远程库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加远程仓库"><span class="nav-number">2.5.2.</span> <span class="nav-text">添加远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从远程仓库抓取数据"><span class="nav-number">2.5.3.</span> <span class="nav-text">从远程仓库抓取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#推送数据到远程仓库"><span class="nav-number">2.5.4.</span> <span class="nav-text">推送数据到远程仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看远程仓库信息"><span class="nav-number">2.5.5.</span> <span class="nav-text">查看远程仓库信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程仓库的删除和重命名"><span class="nav-number">2.5.6.</span> <span class="nav-text">远程仓库的删除和重命名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打标签"><span class="nav-number">2.6.</span> <span class="nav-text">打标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#列显已有的标签"><span class="nav-number">2.6.1.</span> <span class="nav-text">列显已有的标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新建标签"><span class="nav-number">2.6.2.</span> <span class="nav-text">新建标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#含附注的标签"><span class="nav-number">2.6.3.</span> <span class="nav-text">含附注的标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#签署标签"><span class="nav-number">2.6.4.</span> <span class="nav-text">签署标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级标签"><span class="nav-number">2.6.5.</span> <span class="nav-text">轻量级标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证标签"><span class="nav-number">2.6.6.</span> <span class="nav-text">验证标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后期加注标签"><span class="nav-number">2.6.7.</span> <span class="nav-text">后期加注标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分享标签"><span class="nav-number">2.6.8.</span> <span class="nav-text">分享标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#技巧和窍门"><span class="nav-number">2.7.</span> <span class="nav-text">技巧和窍门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动补全"><span class="nav-number">2.7.1.</span> <span class="nav-text">自动补全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-命令别名"><span class="nav-number">2.7.2.</span> <span class="nav-text">Git 命令别名</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tzx</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"tzxhy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
