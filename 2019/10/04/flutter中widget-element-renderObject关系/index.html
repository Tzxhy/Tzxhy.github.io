<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;tzxhy.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12,&quot;b2t&quot;:false,&quot;scrollpercent&quot;:false,&quot;onmobile&quot;:false},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;slideDownIn&quot;,&quot;post_body&quot;:&quot;slideDownIn&quot;,&quot;coll_header&quot;:&quot;slideLeftIn&quot;,&quot;sidebar&quot;:&quot;slideUpIn&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="这一篇我们讲解 flutter 中三大类：Widget、Element、RenderObject 的关系，及在整个应用中的处理时机。 基础讲解这里先讲解基本的概念，再结合代码运行时来说明创建流程及相互关系。">
<meta property="og:type" content="article">
<meta property="og:title" content="flutter中widget&#x2F;element&#x2F;renderObject关系">
<meta property="og:url" content="https://tzxhy.github.io/2019/10/04/flutter%E4%B8%ADwidget-element-renderObject%E5%85%B3%E7%B3%BB/index.html">
<meta property="og:site_name" content="CMeUp">
<meta property="og:description" content="这一篇我们讲解 flutter 中三大类：Widget、Element、RenderObject 的关系，及在整个应用中的处理时机。 基础讲解这里先讲解基本的概念，再结合代码运行时来说明创建流程及相互关系。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/6e47b330c76a9.png">
<meta property="og:image" content="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/f08d238b67c21.png">
<meta property="og:image" content="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/f26970eda73b9.png">
<meta property="og:image" content="https://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/7ae36de4a872c.png">
<meta property="article:published_time" content="2019-10-04T12:33:42.000Z">
<meta property="article:modified_time" content="2021-05-24T09:30:32.410Z">
<meta property="article:author" content="谭智轩">
<meta property="article:tag" content="flutter">
<meta property="article:tag" content="三剑客关系">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/6e47b330c76a9.png">


<link rel="canonical" href="https://tzxhy.github.io/2019/10/04/flutter%E4%B8%ADwidget-element-renderObject%E5%85%B3%E7%B3%BB/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;tzxhy.github.io&#x2F;2019&#x2F;10&#x2F;04&#x2F;flutter%E4%B8%ADwidget-element-renderObject%E5%85%B3%E7%B3%BB&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;10&#x2F;04&#x2F;flutter中widget-element-renderObject关系&#x2F;&quot;,&quot;title&quot;:&quot;flutter中widget&#x2F;element&#x2F;renderObject关系&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>flutter中widget/element/renderObject关系 | CMeUp</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CMeUp</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录一些学习心得，QQ:1139723651.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">基础讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widget"><span class="nav-number">1.1.</span> <span class="nav-text">Widget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element"><span class="nav-number">1.2.</span> <span class="nav-text">Element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F"><span class="nav-number">2.</span> <span class="nav-text">结束</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">谭智轩</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/tzxhy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tzxhy" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/1820446984508072" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;1820446984508072" rel="noopener" target="_blank">掘金</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.yuque.com/tanzhixuan-zebzs" title="语雀 → https:&#x2F;&#x2F;www.yuque.com&#x2F;tanzhixuan-zebzs" rel="noopener" target="_blank">语雀</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://tzxhy.github.io/2019/10/04/flutter%E4%B8%ADwidget-element-renderObject%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="谭智轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CMeUp">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          flutter中widget/element/renderObject关系
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-10-04 12:33:42" itemprop="dateCreated datePublished" datetime="2019-10-04T12:33:42Z">2019-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>这一篇我们讲解 flutter 中三大类：<strong>Widget</strong>、<strong>Element</strong>、<strong>RenderObject</strong> 的关系，及在整个应用中的处理时机。</p>
<h2 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h2><p>这里先讲解基本的概念，再结合代码运行时来说明<strong>创建流程</strong>及<strong>相互关系</strong>。</p>
<span id="more"></span>
<h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>Widget相关的<strong>继承关系</strong>图：<br><img src="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/6e47b330c76a9.png" alt="继承关系"><br>由上图可知，Widget 类是其他类的基类。其下主要有4类：</p>
<ul>
<li>StatelessWidget: 无状态组件。需要实现 build 方法。不多介绍。</li>
<li>StatefulWidget: 有状态组件。需要实现 createState 方法。不多介绍。</li>
<li>ProxyWidget: 代理组件。其下主要是：<ul>
<li>InheritWidget: 继承组件。主要用于在组件树上寻找对应的基类组件，通常用于共享数据。比如 Theme、DefaultTextStyle 等 Widget，可以在任意层组件<strong>向上寻找</strong>最近的<code>InheritWidget</code>基类。</li>
<li>ParentDataWidget: 用于自定义关于父组件存储数据到子组件里的逻辑。比如：<code>Stack</code> 组件的 children 中可以使用 <code>Positioned</code> 组件。其中 <code>Positioned</code> 组件就是 <code>ParentDataWidget</code> 组件，它实现了 <code>applyParentData</code> 方法，用于将该 Widget 的left、right、top、bottom 值写入该 Widget 的 child 对应的 RenderObject 的 parentData 属性中（这句话有点长，你品，你细品）</li>
</ul>
</li>
<li>RenderObjectWidget: 渲染对象组件。虽然该 RenderObjectWidget 按照继承关系来说，是和上面三类 Widget 同一层级，但用途却不一样。上面三类，前两种都可以理解为很多 Widget 的组合，它不能创建新的原生组件，只能使用现有的组件；ProxyWidget 自身没有类似 build 的方法，只保存了一个 child 属性，当然你还能定义各种数据，这才是它的主要作用：作为代理，可以存储数据给所有后代用。<strong>并且当数据改变时，可以通过某种方式通知所有使用过它数据的后台去更新视图</strong>(针对<code>InheritWidget</code>说的)。 该<code>RenderObjectWidget</code>组件的作用不一样：它自己创建对应的 <code>RenderObject</code> 用于控制渲染！大家可能觉得这个会用的很少，比如大部分的 UI 组件官方都提供了，我们用它干啥呢？是不是对我们没用了？<strong>大错特错啦</strong>，所有的 UI 组件的基类都是 <code>RenderObjectWidget</code>！通过该类，我们才能自定义新的 UI 组件（比如官方组件不能满足你的需求，是不是只能自己写一个组件了？虽然通常能使用 StatelessWidget 完成对应的需求，但设计到布局、绘制的，就需要继承该类来自己撸了）。根据子组件的个数，其下分为这么三类：<ul>
<li>SingleChildRenderObjectWidget: 单儿砸组件。比如：Padding、DecoratedBox、ConstrainedBox等（ <strong>有同学也许会说：Container？</strong> 不对，Container 的基类是 StatelessWidget，它只是组合了很多其他的组件，比如刚刚才说的几个）。</li>
<li>MultiChildRenderObjectWidget: 多 child 组件。比如：<code>Stack</code>、<code>Flex</code>等。通常关注的是布局。</li>
<li>LeafRenderObjectWidget: 没儿砸组件，作为叶节点。无布局方法。比如：_SliderRenderObjectWidget（是<code>Slider</code>组件的底层 RenderObjectWidget，该 Widget 对应的 RenderObject <code>_RenderSlider</code> 主要关注绘制，即<code>paint</code>方法，对 layout 相关不感冒）</li>
</ul>
</li>
</ul>
<p>下面是<code>Widget</code>基类的抽象定义：</p>
<p><img src="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/f08d238b67c21.png" alt="widget"><br>其实关注点主要就一个，需要实现一个 createElement 方法。同时也保存了一个 <code>key</code> 属性，用于替换、复用对应的 <code>Element</code>。对于四个子类的细节这里就不细说了（大致可参考上面说的）。关于这四类 <code>Widget</code>，后面单独整理几篇文章来说明（<strong>TODO</strong>） 。下面看一下跟这个<code>Widget</code>相关的<code>Element</code>是什么。</p>
<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><p>同样，首先看一下 <code>Element</code>的继承关系：<br><img src="http://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/f26970eda73b9.png" alt="Element 继承关系"></p>
<p>Element 下就只有两类：</p>
<ul>
<li>ComponentElement: 组件元素。这一类<code>Element</code>主要是组合其他 Element，或者是提供代理功能，分别与 StatelessWidget/StatefulWidget、ProxyWidget 对应。</li>
<li>RenderObjectElement: 渲染对象元素。这与<code>RenderObjectWidget</code>对应。其下的四个子类，除了<code>RootRenderObjectElement</code>外，其余三个，分别与 <code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code> 对应。</li>
</ul>
<p>现在我们需要先理清 <code>Widget</code> 与 <code>Element</code> 的关系，可以通过查看 <code>Widget</code> 和 <code>Element</code>的相关注释发现：</p>
<blockquote>
<p>/// Describes the configuration for an [Element].<br>///<br>/// Widgets are the central class hierarchy in the Flutter framework. A widget<br>/// is an immutable description of part of a user interface. Widgets can be<br>/// inflated into elements, which manage the underlying render tree.</p>
</blockquote>
<p>大致意思是：<code>Widget</code> 是 <code>Element</code> 的配置。<code>Widget</code> 在flutter 中处于中心位置，一个 Widget 是 UI 的不可变描述（如果可变，则使用 StatefulWidget） ，会被碾平为 <code>Element</code>。同时，<code>Element</code> 也管理着底层的渲染树（由 RenderObject 构成的渲染树）。</p>
<p>很好理解了，<code>Widget</code> 只是配置，它只是用来形成 <code>Element</code> 的配置。</p>
<p>根据定义，我们首先简单看一下 <code> BuildContext</code> 定义了什么：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">该 Element 的 Widget 配置</span></span></span><br><span class="line">    Widget <span class="keyword">get</span> widget;</span><br><span class="line">    <span class="comment">/// <span class="markdown">该 Element 的 BuildOwner（控制元素的渲染）</span></span></span><br><span class="line">    BuildOwner <span class="keyword">get</span> owner;</span><br><span class="line">    <span class="comment">/// <span class="markdown">该 Element 持有的 RenderObject</span></span></span><br><span class="line">    RenderObject findRenderObject();</span><br><span class="line">    <span class="comment">/// <span class="markdown">该 Element 持有的 RenderObject 的 size</span></span></span><br><span class="line">    Size <span class="keyword">get</span> size;</span><br><span class="line">    <span class="comment">/// <span class="markdown">注册该 Element 到 ancestor。当 ancestor 改变时，该 Element 也会重建。</span></span></span><br><span class="line">    InheritedWidget inheritFromElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最近的继承组件</span></span></span><br><span class="line">    InheritedWidget inheritFromWidgetOfExactType(<span class="built_in">Type</span> targetType, &#123; <span class="built_in">Object</span> aspect &#125;);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最近的继承组件对应的 Element</span></span></span><br><span class="line">    InheritedElement ancestorInheritedElementForWidgetOfExactType(<span class="built_in">Type</span> targetType);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最近的指定类型的组件</span></span></span><br><span class="line">    Widget ancestorWidgetOfExactType(<span class="built_in">Type</span> targetType);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最近的指定类型的 State 对象</span></span></span><br><span class="line">    State ancestorStateOfType(TypeMatcher matcher);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最远的指定类型的 State 对象</span></span></span><br><span class="line">    State rootAncestorStateOfType(TypeMatcher matcher);</span><br><span class="line">    <span class="comment">/// <span class="markdown">获取最近的指定类型的 RenderObject 对象</span></span></span><br><span class="line">    RenderObject ancestorRenderObjectOfType(TypeMatcher matcher);</span><br><span class="line">    <span class="comment">/// <span class="markdown">向上遍历所有父 element。当到 root 或者 visitor 返回 false 时，停止遍历</span></span></span><br><span class="line">    <span class="keyword">void</span> visitAncestorElements(<span class="built_in">bool</span> visitor(<span class="built_in">Element</span> element));</span><br><span class="line">    <span class="comment">/// <span class="markdown">遍历 children</span></span></span><br><span class="line">    <span class="keyword">void</span> visitChildElements(ElementVisitor visitor);</span><br><span class="line"></span><br><span class="line">    DiagnosticsNode describeElement(<span class="built_in">String</span> name, &#123;DiagnosticsTreeStyle style = DiagnosticsTreeStyle.errorProperty&#125;);</span><br><span class="line"></span><br><span class="line">    DiagnosticsNode describeWidget(<span class="built_in">String</span> name, &#123;DiagnosticsTreeStyle style = DiagnosticsTreeStyle.errorProperty&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>&lt;DiagnosticsNode&gt; describeMissingAncestor(&#123; <span class="meta">@required</span> <span class="built_in">Type</span> expectedAncestorType &#125;);</span><br><span class="line"></span><br><span class="line">    DiagnosticsNode describeOwnershipChain(<span class="built_in">String</span> name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限于篇幅，去掉了原注释，添加了简短的中文注释。是不是有些方法看着很眼熟？<code>ancestorWidgetOfExactType</code>、<code>inheritFromWidgetOfExactType</code>等方法，我们都经常在<code>build</code>方法中使用吧？是的，因为<code>Widget.build(BuildContext context)</code> 中的<code>context</code>，指的就是这个 <code>Widget</code> 对应的 <code>Element</code>，而 <code>Element</code> 又实现了 <code>BuildContext</code>，那这一切就理所当然了。对于<code>Widget</code>的上层组件，由于都比较简单，这里就不细说了，大家可以看看源码。</p>
<p>看一下 <code>Element</code> ？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// <span class="markdown">使用 widget 创建一个 element</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">通常由[Widget.createElement]调用</span></span></span><br><span class="line">    <span class="built_in">Element</span>(Widget widget)</span><br><span class="line">    : <span class="keyword">assert</span>(widget != <span class="keyword">null</span>),</span><br><span class="line">      _widget = widget;</span><br><span class="line">    <span class="comment">/// <span class="markdown">父元素</span></span></span><br><span class="line">    <span class="built_in">Element</span> _parent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other) =&gt; identical(<span class="keyword">this</span>, other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">父元素设置 child 如何在 child list 中适应</span></span></span><br><span class="line">    <span class="built_in">dynamic</span> <span class="keyword">get</span> slot =&gt; _slot;</span><br><span class="line">    <span class="built_in">dynamic</span> _slot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">元素的深度</span></span></span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">get</span> depth =&gt; _depth;</span><br><span class="line">    <span class="built_in">int</span> _depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">按深度和赃值排序</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> _sort(<span class="built_in">Element</span> a, <span class="built_in">Element</span> b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">该 element 的 widget</span></span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget <span class="keyword">get</span> widget =&gt; _widget;</span><br><span class="line">    Widget _widget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">BuildOwner</span></span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    BuildOwner <span class="keyword">get</span> owner =&gt; _owner;</span><br><span class="line">    BuildOwner _owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">该元素状态。当 mount/activate 时为true，当deactive 时为 false</span></span></span><br><span class="line">    <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">开发时热重载。release 下不可用。</span></span></span><br><span class="line">    <span class="keyword">void</span> reassemble() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">返回 element 的 renderObject</span></span></span><br><span class="line">    RenderObject <span class="keyword">get</span> renderObject &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> visitChildren(ElementVisitor visitor) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">通过新的 widget 来更新指定的 chld element.</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">这是非常重要的一个方法。</span></span></span><br><span class="line">    <span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">挂载元素。设置 <span class="emphasis">_parent _</span>slot <span class="emphasis">_depth _</span>active等属性</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">同时设置 继承组件</span></span></span><br><span class="line">    <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">更新 widget</span></span></span><br><span class="line">    <span class="keyword">void</span> update(<span class="keyword">covariant</span> Widget newWidget) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">改变 children 中各个 child 的 slot。通常是 child 在 children 列表中改变顺序后调用。</span></span></span><br><span class="line">    <span class="keyword">void</span> updateSlotForChild(<span class="built_in">Element</span> child, <span class="built_in">dynamic</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">分离 RenderObject （这里是置 <span class="emphasis">_slot 为 null）</span></span></span></span><br><span class="line">    <span class="keyword">void</span> detachRenderObject() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">添加到 RenderObject 树（这里是置_</span>slot 为 newSlot）</span></span></span><br><span class="line">    <span class="keyword">void</span> attachRenderObject(<span class="built_in">dynamic</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">将 newWidget 碾平为一个 Element</span></span></span><br><span class="line">    <span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">将指定的 child 移入非活跃 对象列表，并且分离它的 renderObject</span></span></span><br><span class="line">    <span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">移除 child</span></span></span><br><span class="line">    <span class="keyword">void</span> forgetChild(<span class="built_in">Element</span> child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">从 非活跃 到 活跃</span></span></span><br><span class="line">    <span class="keyword">void</span> activate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">与上相反</span></span></span><br><span class="line">    <span class="keyword">void</span> deactivate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">从 非活跃 到 失效 状态</span></span></span><br><span class="line">    <span class="keyword">void</span> unmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    RenderObject findRenderObject() =&gt; renderObject;</span><br><span class="line"></span><br><span class="line">    Size <span class="keyword">get</span> size &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt; _inheritedWidgets;</span><br><span class="line">    <span class="built_in">Set</span>&lt;InheritedElement&gt; _dependencies;</span><br><span class="line">    <span class="built_in">bool</span> _hadUnsatisfiedDependencies = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    InheritedWidget inheritFromElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    InheritedWidget inheritFromWidgetOfExactType(<span class="built_in">Type</span> targetType, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    InheritedElement ancestorInheritedElementForWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">        _inheritedWidgets = _parent?._inheritedWidgets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget ancestorWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    State ancestorStateOfType(TypeMatcher matcher) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    State rootAncestorStateOfType(TypeMatcher matcher) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    RenderObject ancestorRenderObjectOfType(TypeMatcher matcher) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> visitAncestorElements(<span class="built_in">bool</span> visitor(<span class="built_in">Element</span> element)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">当该 element 的依赖改变时会调用。</span></span></span><br><span class="line">    <span class="keyword">void</span> didChangeDependencies() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> dirty =&gt; _dirty;</span><br><span class="line">    <span class="built_in">bool</span> _dirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> _inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// <span class="markdown">设置 <span class="emphasis">_dirty，安排上 build</span></span></span></span><br><span class="line">    <span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">        _dirty = <span class="keyword">true</span>;</span><br><span class="line">        owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">重建。就只是调用 performRebuild()</span></span></span></span><br><span class="line">    <span class="keyword">void</span> rebuild() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> performRebuild();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很长的 API，但主要是处理_slot/_active/_dirty/_parent等。现在还比较乱，等结合上层 api 时再细看。</p>
<p>看一下常用到的<code>StatelessElement</code>:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StatelessElement(StatelessWidget widget) : <span class="keyword">super</span>(widget);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    StatelessWidget <span class="keyword">get</span> widget =&gt; <span class="keyword">super</span>.widget;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build() =&gt; widget.build(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> update(StatelessWidget newWidget) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地重写了几个方法。<code>StatefulWidget</code>呢：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StatefulElement(StatefulWidget widget)</span><br><span class="line">      : _state = widget.createState(),</span><br><span class="line">        <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">            _state._element = <span class="keyword">this</span>;</span><br><span class="line">            _state._widget = widget;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build() =&gt; state.build(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    State&lt;StatefulWidget&gt; <span class="keyword">get</span> state =&gt; _state;</span><br><span class="line">    State&lt;StatefulWidget&gt; _state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> reassemble() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> update(StatefulWidget newWidget) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> activate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> deactivate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> unmount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    InheritedWidget inheritFromElement(<span class="built_in">Element</span> ancestor, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> didChangeDependencies() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他<code>Element</code>先不看了，继续看<code>RenderObject</code>。</p>
<p><code>RenderObject</code>是何时创建的呢？首先我们需要知道的是，虽然对于用户来说，编写的基本都是<code>Widget</code>，但对于框架来说，三者建立连接的地方是<code>Element</code>。何以见得呢？因为细看上面的 <code>Element</code>简版，发现它持有了 <code>_widget</code> 和 <code>_renderObject</code>。在<code>Element.update</code>方法中，更新了<code>_widget</code>；在 <code>RenderObjectElement.mount</code>方法中，更新 <code>_renderObject</code>。好，接下来简单看一下 <code>RenderObject</code> 是做什么的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">渲染树中的一个对象。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> <span class="keyword">extends</span> <span class="title">AbstractNode</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> <span class="keyword">implements</span> <span class="title">HitTestTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">开发时用。重建当前 renderObject</span></span></span><br><span class="line">    <span class="keyword">void</span> reassemble() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAYOUT相关</span></span><br><span class="line">    <span class="comment">/// <span class="markdown">父 renderObject 需要使用的数据。比如 Flex 下的 child</span></span></span><br><span class="line">    ParentData parentData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">设置 parentData</span></span></span><br><span class="line">    <span class="keyword">void</span> setupParentData(<span class="keyword">covariant</span> RenderObject child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">当 child list 改变时调用</span></span></span><br><span class="line">    <span class="keyword">void</span> adoptChild(RenderObject child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">丢弃一个 child</span></span></span><br><span class="line">    <span class="keyword">void</span> dropChild(RenderObject child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">遍历</span></span></span><br><span class="line">    <span class="keyword">void</span> visitChildren(RenderObjectVisitor visitor) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">owner</span></span></span><br><span class="line">    PipelineOwner <span class="keyword">get</span> owner =&gt; <span class="keyword">super</span>.owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">设置 <span class="emphasis">_owner 调用 need* 方法</span></span></span></span><br><span class="line">    <span class="keyword">void</span> attach(PipelineOwner owner) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> _needsLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">重排边界对象</span></span></span></span><br><span class="line">    RenderObject _relayoutBoundary;</span><br><span class="line">    <span class="built_in">bool</span> _doingThisLayoutWithCallback = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">父 renderObject 传入的限制</span></span></span></span><br><span class="line">    Constraints <span class="keyword">get</span> constraints =&gt; _constraints;</span><br><span class="line">    Constraints _constraints;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">标记为脏。owner._</span>nodesNeedingLayout.add(this);</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">owner.requestVisualUpdate();</span></span></span><br><span class="line">    <span class="keyword">void</span> markNeedsLayout() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> markParentNeedsLayout() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">同时调用上面两个</span></span></span><br><span class="line">    <span class="keyword">void</span> markNeedsLayoutForSizedByParentChange() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown">安排首次布局</span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown">owner.<span class="emphasis">_nodesNeedingLayout.add(this);</span></span></span></span><br><span class="line">    <span class="keyword">void</span> scheduleInitialLayout() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">为当前 renderObject 布局。</span></span></span></span><br><span class="line">    <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">约束条件是否是大小调整算法的唯一输入</span></span></span></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> sizedByParent =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">使用限制来计算 size。</span></span></span></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">不需要直接调用。调用 layout。</span></span></span></span><br><span class="line">    <span class="keyword">void</span> performResize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">布局。不直接调用。调用 layout。</span></span></span></span><br><span class="line">    <span class="keyword">void</span> performLayout();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PAINTING</span></span><br><span class="line">    <span class="comment">/// <span class="markdown"><span class="emphasis">是否是绘制边界</span></span></span></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> isRepaintBoundary =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> alwaysNeedsCompositing =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ContainerLayer <span class="keyword">get</span> layer &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> layer(ContainerLayer newLayer) &#123;&#125;</span><br><span class="line">    ContainerLayer _layer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> markNeedsCompositingBitsUpdate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> _needsCompositing;</span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> needsCompositing &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> markNeedsPaint() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> scheduleInitialPaint(ContainerLayer rootLayer) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> replaceRootLayer(OffsetLayer rootLayer) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Rect <span class="keyword">get</span> paintBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> applyPaintTransform(<span class="keyword">covariant</span> RenderObject child, Matrix4 transform) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Matrix4 getTransformTo(RenderObject ancestor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EVENTS</span></span><br><span class="line">    <span class="keyword">void</span> handleEvent(PointerEvent event, <span class="keyword">covariant</span> HitTestEntry entry) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HIT TESTING</span></span><br><span class="line">    <span class="built_in">bool</span> hitTest(HitTestResult result, &#123; Offset position &#125;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下<code>RenderObject</code>的继承关系：<br><img src="https://www.tanzhixuan.top/ng-s1/static/upload/img/6be26730/7ae36de4a872c.png" alt="RenderObject 继承关系"></p>
<p>由此我们知道所有的实体 <code>RenderObject</code>都是<code>RenderBox</code>类型。来看一下 <code>RenderBox</code> 是做了什么：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderBox</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setupParentData(<span class="keyword">covariant</span> RenderObject child) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> getMinIntrinsicWidth(<span class="built_in">double</span> height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> computeMinIntrinsicWidth(<span class="built_in">double</span> height) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> <span class="keyword">get</span> hasSize =&gt; _size != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Size <span class="keyword">get</span> size &#123;&#125;</span><br><span class="line">    Size _size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> size(Size value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> getDistanceToActualBaseline(TextBaseline baseline) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> getDistanceToBaseline(TextBaseline baseline, &#123; <span class="built_in">bool</span> onlyReal = <span class="keyword">false</span> &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> computeDistanceToActualBaseline(TextBaseline baseline) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    BoxConstraints <span class="keyword">get</span> constraints =&gt; <span class="keyword">super</span>.constraints;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> markNeedsLayout() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> performResize() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> performLayout() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hitTest(BoxHitTestResult result, &#123; <span class="meta">@required</span> Offset position &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hitTestSelf(Offset position) =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hitTestChildren(BoxHitTestResult result, &#123; Offset position &#125;) =&gt; <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> applyPaintTransform(RenderObject child, Matrix4 transform) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Offset globalToLocal(Offset point, &#123; RenderObject ancestor &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Offset localToGlobal(Offset point, &#123; RenderObject ancestor &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Rect <span class="keyword">get</span> paintBounds =&gt; Offset.zero &amp; size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> handleEvent(PointerEvent event, BoxHitTestEntry entry) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这三大基础后，可能仍然一头雾水？我们直接看看构建流程，这样最清晰了。</p>
<p>在上篇中，说到：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了<code>attachToRenderTree</code>这个方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(</span><br><span class="line">    BuildOwner owner,</span><br><span class="line">    [ RenderObjectToWidgetElement&lt;T&gt; element ]</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner.lockState(() &#123;</span><br><span class="line">            element = createElement();</span><br><span class="line">            <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">            element.assignOwner(owner);</span><br><span class="line">        &#125;);</span><br><span class="line">        owner.buildScope(element, () &#123;</span><br><span class="line">            element.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">        element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当首次mount时（即 element 为 null）， 这时先通过 <code>createElement</code> 创建一个 element，该 element 作为顶层 element。然后通过 buildScope 方法（构建一个壳，防止潜在的无限循环），传入一个 <code>element.mount(null, null);</code> 作为 callback。然后对所有 dirtyElement 进行 <code>rebuild</code> 操作。直接看代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">RenderObjectToWidgetElement</span></span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据继承关系，向上调用了一连串的 <code>mount</code> 方法。主要操作有，在 <code>RenderObjectElement</code>层：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">RenderObjectElement</span></span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会创建对应的<code>RenderObject</code>，并且 attach 对应的 slot（attachRenderObject里会有代理组件处理 RenderObject 的逻辑，这个后面单独说）。上面说<code>Widget</code>分类时，说到了 <code>RenderObjectWidget</code>(就是其下有单儿子、多儿子、叶节点的那个)。这里的 <code>widget</code> 就是 <code>RenderObjectWidget</code>类型。<br>在根<code>Element</code>层，到达了 <code>mount</code>方法的终点，这里上面说过了，就是设置一些内部值，比如_parent/_slot 等，以及标志依赖组件。到此结束了 <code>mount</code>。回到 <code>RenderObjectToWidgetElement._rebuild</code>方法。</p>
<p>在 <code>_rebuild</code>中，只是调用了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_child = updateChild(_child, widget.child, _rootChildSlot);</span><br></pre></td></tr></table></figure>
<p>到了 <code>Element.updateChild</code>方法了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">        updateSlotForChild(child, newSlot);</span><br><span class="line">      child.update(newWidget);</span><br><span class="line">      <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">    deactivateChild(child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实先说一下官方注释，便于理解：</p>
<blockquote>
<p>该方法是组件系统的核心。它会在我们要去增加、更新、删除一个widget时调用。<br>如果 <code>child</code> 为空，<code>newWidget</code> 不为空，就创建一个以 <code>newWidget</code> 作为配置的新的 <code>Element</code>；<br>如果 <code>newWidget</code> 为空，<code>child</code> 不为空，就移除 <code>child</code>；<br>如果都不为空，如果通过了 <code>Widget.canUpdate</code>，则用 <code>newWidget</code> 去更新 <code>child</code>，否则移除<code>child</code>，并创建一个新的 <code>Element</code>；<br>都为空，则什么都不做。</p>
</blockquote>
<p>先简单看一下，移除、更新、创建的逻辑：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">移除</span></span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">null</span>;</span><br><span class="line">  child.detachRenderObject();</span><br><span class="line">  owner._inactiveElements.add(child); <span class="comment">// 关键点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">更新</span></span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> updateSlotForChild(<span class="built_in">Element</span> child, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">void</span> visit(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    element._updateSlot(newSlot);</span><br><span class="line">    <span class="keyword">if</span> (element <span class="keyword">is</span>! RenderObjectElement)</span><br><span class="line">      element.visitChildren(visit);</span><br><span class="line">  &#125;</span><br><span class="line">  visit(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@mustCallSuper</span></span><br><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> Widget newWidget) &#123;</span><br><span class="line">  _widget = newWidget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">创建</span></span></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key key = newWidget.key;</span><br><span class="line">  <span class="comment">// 如果是使用的 GlobalKey</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是新的 GLobalKey 或者没使用 GlobalKey，调用 `Widget.createElement`</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  <span class="comment">// 递归地 `mount`</span></span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>精妙之处就在 <code>inflateWidget</code>中的这个 <code>mount</code>，它递归调用了所有 widget 对应的 element 的 <code>mount</code>，由此生成一颗 <code>Element</code>树。最终返回了顶层元素，赋给 <code>_renderViewElement</code>。至此，<code>attachRootWidget</code> 方法就返回了。下一步是安排渲染，即：<code>scheduleWarmUpFrame</code>。这一块是某一篇文章说过的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="comment">// 执行绘制前的准备工作。同时执行所有临时回调(由[scheduleFrameCallback]注册)</span></span><br><span class="line">    handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  Timer.run(() &#123;</span><br><span class="line">    <span class="comment">// 在调用 [handleBeginFrame] 后立即调用。执行所有由 [addPersistentFrameCallback]</span></span><br><span class="line">    <span class="comment">// 添加的回调，比如布局、绘制、合成等持久回调，之后调用所有由[addPostFrameCallback]添加</span></span><br><span class="line">    <span class="comment">// 的回调。</span></span><br><span class="line">    handleDrawFrame();</span><br><span class="line">    resetEpoch();</span><br><span class="line">    _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">      scheduleFrame();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过全局查找 [addPersistentFrameCallback]，定位到它的回调为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即一次屏幕刷新的全流程：</p>
<ol>
<li>布局</li>
<li>更新合成位</li>
<li>绘制</li>
<li>合成帧</li>
<li>语意化</li>
</ol>
<p>简单先看一下布局的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Update the layout information for all dirty render objects.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This function is one of the core stages of the rendering pipeline. Layout</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">information is cleaned prior to painting so that render objects will</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">appear on screen in their up-to-date locations.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">See [RendererBinding] for an example of how this function is used.</span></span></span><br><span class="line">  <span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      Timeline.startSync(<span class="string">&#x27;Layout&#x27;</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">            node._layoutWithoutResize();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">        Timeline.finishSync();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>就是遍历 <code>_nodesNeedingLayout</code>。那么这些脏节点什么时候加上的呢？我翻看了之前 <code>RenderObjectToWidgetElement.mount</code> 方法，也只是构建 <code>Element</code>树，并没有任何设置脏节点的逻辑。那么这个逻辑是在哪加的呢？答案是在<code>RendererBinding</code> 的 <code>initInstances</code> 方法里，调用了 <code>initRenderView</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RendererBinding</span></span><br><span class="line"><span class="keyword">void</span> initRenderView() &#123;</span><br><span class="line">  <span class="comment">// 生成</span></span><br><span class="line">  renderView = RenderView(configuration: createViewConfiguration(), <span class="built_in">window</span>: <span class="built_in">window</span>);</span><br><span class="line">  renderView.scheduleInitialFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderView</span></span><br><span class="line"><span class="keyword">void</span> scheduleInitialFrame() &#123;</span><br><span class="line">  scheduleInitialLayout(); <span class="comment">// 这里添加了根 RenderObject 节点哦</span></span><br><span class="line">  <span class="comment">// 添加需要绘制的根节点</span></span><br><span class="line">  scheduleInitialPaint(_updateMatricesAndCreateNewRootLayer()); </span><br><span class="line">  owner.requestVisualUpdate(); <span class="comment">// 请求刷新页面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="keyword">void</span> scheduleInitialLayout() &#123;</span><br><span class="line">  _relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  owner._nodesNeedingLayout.add(<span class="keyword">this</span>); <span class="comment">// 这里添加了根 RenderObject 节点哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="keyword">void</span> scheduleInitialPaint(ContainerLayer rootLayer) &#123;</span><br><span class="line">  _layer = rootLayer;</span><br><span class="line">  owner._nodesNeedingPaint.add(<span class="keyword">this</span>); <span class="comment">// 添加需要绘制的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在初始化 FlutterBinding 的时候，就将根 RenderObject 放入脏节点了，所以后面第一次更新肯定是包含该脏节点的。</p>
<p>但有一个问题（尚未验证）：这里 <code>initInstances</code> 方法中就请求了更新视图，为什么还需要调用 <code>scheduleWarmUpFrame</code> 来触发更新呢？是不是首次渲染多了一次？？这里记个 TODO</p>
<p>继续看布局：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">  RenderObject debugPreviousActiveLayout;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点是 <code>performLayout</code> 和 <code>markNeedsPaint</code>。下层 RenderBox 也没有实现 <code>performLayout</code>，我们随便找一个单儿子的RenderObject 来看一下。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">RenderLimitedBox</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 布局儿子</span></span><br><span class="line">      child.layout(_limitConstraints(constraints), parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">      size = constraints.constrain(child.size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      size = _limitConstraints(constraints).constrain(Size.zero);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>是不是有点奇怪，为什么要给儿子布局，而不是给自己布局？这就需要了解 flutter 布局这一层的东西了。flutter 中布局相关的东西，主要是 parentData.offset，size。每个 RenderObject 有自己的 <code>parentData</code>。看名字也好理解：爸爸的数据。所以它是父 RenderObject 给儿子设置的数据。那么通常需要设置哪些数据呢？<code>offset</code>就是其中之一，它代表儿子在爸爸这里的偏移（水平和垂直方向）。每一个 RenderObject 还有一个 size 属性，表示自己这个渲染对象占据的屏幕尺寸。由上面的代码，可得：先把儿子布好局，安排好（儿子又会递归地给儿子的儿子布局..）后，就知道儿子的大小了。一般场景下，爸爸会和儿子的大小相关，比如上面的把爸爸的大小设置为与儿子大小成限制关系。我理解的布局就是递归地设置<code>offset</code>和<code>size</code>，这也正好符合 <code>RenderBox</code> 的名称：所有渲染对象都是盒子，盒子不就是一层嵌套一层，A 盒子大小多少，B 盒子大小多少，B 盒子的儿子 B1盒子大小、相对于 B 盒子的偏移…渲染对象仅包含布局相关相关（当然，也能绘制，比如背景色、自定义图形等），更多的数据还是保存在 <code>Element</code>中。毕竟 <code>Element</code>是沟通 <code>Widget</code> 和 <code>RenderObject</code>的桥梁。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObject</span></span><br><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsPaint)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 重绘边界的话，不用更新 parent</span></span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="comment">// If we always have our own layer, then we can just repaint</span></span><br><span class="line">    <span class="comment">// ourselves without involving any other nodes.</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123; <span class="comment">// 非重绘边界，更新爸爸</span></span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re the root of the render tree (probably a RenderView),</span></span><br><span class="line">    <span class="comment">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class="line">    <span class="comment">// us. We don&#x27;t add ourselves to _nodesNeedingPaint in this</span></span><br><span class="line">    <span class="comment">// case, because the root is always told to paint regardless.</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，不管是 markNeedsLayout 还是 paint，都需要给 owner 对应的队列添加当前元素。还有一个主要的操作是生成合成层：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> compositeFrame() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class="line">      <span class="keyword">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class="line">      <span class="keyword">if</span> (automaticSystemUiAdjustment)</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      _<span class="built_in">window</span>.render(scene);</span><br><span class="line">      scene.dispose();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，数据就呈现到屏幕上了。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>大致讲解了<code>Widget</code>/<code>Element</code>/<code>RenderObject</code>的关系和作用。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/flutter/" rel="tag"># flutter</a>
              <a href="/tags/%E4%B8%89%E5%89%91%E5%AE%A2%E5%85%B3%E7%B3%BB/" rel="tag"># 三剑客关系</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/09/22/Node-js%E4%B8%AD%E7%9B%91%E6%8E%A7%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%82%E5%B8%B8/" rel="prev" title="Nodejs中监控事件循环异常">
                  <i class="fa fa-chevron-left"></i> Nodejs中监控事件循环异常
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/10/27/flutter-%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3/" rel="next" title="flutter 中路由详解">
                  flutter 中路由详解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MjY5OS8yOTE3Ng=="></div><script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谭智轩</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
