<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;tzxhy.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12,&quot;b2t&quot;:false,&quot;scrollpercent&quot;:false,&quot;onmobile&quot;:false},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;slideDownIn&quot;,&quot;post_body&quot;:&quot;slideDownIn&quot;,&quot;coll_header&quot;:&quot;slideLeftIn&quot;,&quot;sidebar&quot;:&quot;slideUpIn&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script>
<meta name="description" content="官网原文 Docker 能够通过 Dockerfile 文件中的指令来自动构建镜像。一个 Dockerfile 文件是一个包含用户能够调用所有命令去构建新的镜像的文档的集合。使用 docker build 命令，用户可以创建一个基于连续的指令而自动构建镜像。 这篇文章描述了能在 Dockerfile 中使用的指令。当你完成阅读这篇文章，可以看看 Dockerfile 最佳实践，作为提示导向的指导。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile 作用(翻译自官网)">
<meta property="og:url" content="https://tzxhy.github.io/2021/05/25/Dockerfile-%E4%BD%9C%E7%94%A8/index.html">
<meta property="og:site_name" content="CMeUp">
<meta property="og:description" content="官网原文 Docker 能够通过 Dockerfile 文件中的指令来自动构建镜像。一个 Dockerfile 文件是一个包含用户能够调用所有命令去构建新的镜像的文档的集合。使用 docker build 命令，用户可以创建一个基于连续的指令而自动构建镜像。 这篇文章描述了能在 Dockerfile 中使用的指令。当你完成阅读这篇文章，可以看看 Dockerfile 最佳实践，作为提示导向的指导。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-25T10:07:22.000Z">
<meta property="article:modified_time" content="2022-02-11T06:59:05.990Z">
<meta property="article:author" content="谭智轩">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tzxhy.github.io/2021/05/25/Dockerfile-%E4%BD%9C%E7%94%A8/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;tzxhy.github.io&#x2F;2021&#x2F;05&#x2F;25&#x2F;Dockerfile-%E4%BD%9C%E7%94%A8&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;25&#x2F;Dockerfile-作用&#x2F;&quot;,&quot;title&quot;:&quot;Dockerfile 作用(翻译自官网)&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Dockerfile 作用(翻译自官网) | CMeUp</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CMeUp</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录一些学习心得，QQ:1139723651.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BuildKit"><span class="nav-number">2.</span> <span class="nav-text">BuildKit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">解析器指令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#syntax"><span class="nav-number">5.</span> <span class="nav-text">syntax</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%98%E6%96%B9%E5%8F%91%E5%B8%83%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">官方发布（略）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#escape%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">escape（略）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">7.</span> <span class="nav-text">环境变量替换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dockerignore-%E6%96%87%E4%BB%B6%EF%BC%88%E7%95%A5%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">.dockerignore 文件（略）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FROM"><span class="nav-number">9.</span> <span class="nav-text">FROM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3-ARG-%E5%92%8C-FROM-%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="nav-number">9.1.</span> <span class="nav-text">理解 ARG 和 FROM 的交互</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RUN"><span class="nav-number">10.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CMD"><span class="nav-number">11.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LABEL"><span class="nav-number">12.</span> <span class="nav-text">LABEL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EXPOSE"><span class="nav-number">13.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ENV"><span class="nav-number">14.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ADD"><span class="nav-number">15.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#COPY"><span class="nav-number">16.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">17.</span> <span class="nav-text">ENTRYPOINT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.1.</span> <span class="nav-text">exec 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shell-%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.2.</span> <span class="nav-text">shell 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMD-%E4%B8%8E-ENTRYPOINT-%E4%BA%A4%E4%BA%92"><span class="nav-number">17.3.</span> <span class="nav-text">CMD 与 ENTRYPOINT 交互</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VOLUME"><span class="nav-number">18.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#USER"><span class="nav-number">19.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WORKDIR"><span class="nav-number">20.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARG"><span class="nav-number">21.</span> <span class="nav-text">ARG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">21.1.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">21.2.</span> <span class="nav-text">作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ONBUILD"><span class="nav-number">22.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">23.</span> <span class="nav-text">HEALTHCHECK</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">谭智轩</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/tzxhy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tzxhy" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/1820446984508072" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;1820446984508072" rel="noopener" target="_blank">掘金</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.yuque.com/tanzhixuan-zebzs" title="语雀 → https:&#x2F;&#x2F;www.yuque.com&#x2F;tanzhixuan-zebzs" rel="noopener" target="_blank">语雀</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://tzxhy.github.io/2021/05/25/Dockerfile-%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="谭智轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CMeUp">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dockerfile 作用(翻译自官网)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-25 10:07:22" itemprop="dateCreated datePublished" datetime="2021-05-25T10:07:22Z">2021-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">官网原文</a></p>
<p>Docker 能够通过 <code>Dockerfile</code> 文件中的指令来自动构建镜像。一个 <code>Dockerfile</code> 文件是一个包含用户能够调用所有命令去构建新的镜像的文档的集合。使用 <code>docker build</code> 命令，用户可以创建一个基于连续的指令而自动构建镜像。</p>
<p>这篇文章描述了能在 <code>Dockerfile</code> 中使用的指令。当你完成阅读这篇文章，可以看看 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Dockerfile 最佳实践</a>，作为提示导向的指导。</p>
<span id="more"></span>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>docker build</code> 命令从一个 <code>Dockerfile</code> 文件和一个 <code>环境</code> 来构建镜像。构建的环境是指一个具体 <code>PATH</code> 下的文件集合或者是一个 <code>URL</code>。<code>PATH</code> 是一个你本地文件系统的目录，<code>URL</code> 是一个 Git 仓库地址。</p>
<p>构建环境会被递归地处理，因此，一个 <code>PATH</code> 如果包含了任意的子目录，或者是 <code>URL</code> 包含了子模块，都会被递归处理。下面的例子展示了在当前目录 <code>.</code> 作为构建环境， 使用 build 命令生成镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build .</span><br></pre></td></tr></table></figure>

<p>构建过程是被 <code>Docker daemon</code> 执行的，不是 cli。构建过程的首要工作是发送整个环境（递归的）给后台驻留程序（daemon）。在绝大部分场景中，最好是将一个空目录作为构建环境，并且保证你的 <code>Dockerfile</code> 文件在那个目录中。 <strong>只添加构建过程中必要的文件。</strong></p>
<blockquote>
<p><strong>警告：<br/></strong><br>不要在根目录，也就是 <code>/</code> 下，作为构建目录，因为它会造成构建过程中传递整个文件系统给 Docker 后台驻留程序。</p>
</blockquote>
<p>在构建环境中使用一个文件，<code>Dockerfile</code> 指引着具体的文件，比如，一个 <code>COPY</code> 指令。为了增加构建的效率，可以通过添加 <code>.dockerignore</code> 文件到构建环境目录里，排除某些文件。关于如何使用 <code>.dockerignore</code> ，可以查看<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">文档</a>。</p>
<p>传统上，<code>Dockerfile</code> 文件就命名为：Dockerfile，而且就有构建环境的根上。你也可以在 <code>docker build</code> 上使用 <code>-f</code> 选项来指向你文件系统上的 Dockerfile 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/your/Dockerfile .</span><br></pre></td></tr></table></figure>

<p>你可以指定一个仓库和标签，当新镜像构建成功后，会使用 仓库/标签 的形势存储这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure>

<p>如果要命名为多个仓库，可以添加多个 <code>-t</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure>

<p>在 Docker daemon 开始执行 <code>Dockerfile</code> 中的指令之前，它会执行一次预校验，如果语法错误，会直接返回错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="built_in">test</span>/myapp .</span><br><span class="line"></span><br><span class="line">[+] Building 0.3s (2/2) FINISHED</span><br><span class="line">=&gt; [internal] load build definition from Dockerfile                       0.1s</span><br><span class="line">=&gt; =&gt; transferring dockerfile: 60B                                        0.0s</span><br><span class="line">=&gt; [internal] load .dockerignore                                          0.1s</span><br><span class="line">=&gt; =&gt; transferring context: 2B                                            0.0s</span><br><span class="line">error: failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to create LLB definition:</span><br><span class="line">dockerfile parse error line 2: unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>

<p>Docker daemon 一个接一个的执行 <code>Dockerfile</code> 里的指令，如果有必要，在最终输出你的新镜像 ID 之前，会提交每一个指令的结果给新的镜像。Docker daemon 会自动把构建环境清理干净。</p>
<p>注意到，每一个指令都是独立执行的，并且会导致产生新的镜像。因此， <code>RUN cd /tmp</code> 不会对下一条指令有任何影响。</p>
<p>如何可能，Docker 会使用构建缓存来显著提升 <code>docker build</code> 性能。这可以通过控制台的 console 输出看到，带有 <code>CACHED</code> 信息（更多信息可查看[Dockerfile 最佳实践](<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/%EF%BC%89">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/）</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker build -t svendowideit/ambassador .</span><br><span class="line"></span><br><span class="line">=&gt; [internal] load build definition from Dockerfile                       0.1s</span><br><span class="line">=&gt;  =&gt; transferring dockerfile: 286B                                       0.0s</span><br><span class="line">=&gt;  [internal] load .dockerignore                                          0.1s</span><br><span class="line">=&gt;  =&gt; transferring context: 2B                                            0.0s</span><br><span class="line">=&gt;  [internal] load metadata <span class="keyword">for</span> docker.io/library/alpine:3.2              0.4s</span><br><span class="line">=&gt;  CACHED [1/2] FROM docker.io/library/alpine:3.2@sha256:e9a2035f9d0d7ce  0.0s</span><br><span class="line">=&gt;  CACHED [2/2] RUN apk add --no-cache socat                              0.0s</span><br><span class="line">=&gt;  exporting to image                                                     0.0s</span><br><span class="line">=&gt;  =&gt; exporting layers                                                    0.0s</span><br><span class="line">=&gt;  =&gt; writing image sha256:1affb80ca37018ac12067fa2af38cc5bcc2a8f09963de  0.0s</span><br><span class="line">=&gt;  =&gt; naming to docker.io/svendowideit/ambassador                         0.0s</span><br></pre></td></tr></table></figure>

<p>构建缓存默认上是基于上一次构建过程。 <code>--cache-from</code> 选项也让你能使用分发到镜像仓库的构建缓存，可参阅 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/build/#specifying-external-cache-sources">指定外部缓存源</a> 章节中的 <code>docker build</code> 命名索引处。</p>
<p>当你构建完成后，你可以通过 <code>docker scan</code> 来查看你的镜像，也可以将它推送到 Docker Hub。</p>
<h1 id="BuildKit"><a href="#BuildKit" class="headerlink" title="BuildKit"></a>BuildKit</h1><p>从版本 18.09 开始，Docker 支持了新的构建后端，由 moby/buildkit 项目支持。BuildKit 后端提供了相对于老的实现方式更多的优势，包括：</p>
<ul>
<li>检测和跳过执行无用的构建阶段</li>
<li>并行构建独立的构建阶段</li>
<li>在多次构建中，增量传递构建环境中变化了的文件</li>
<li>在构建环境中检测和跳过传递无用的文件</li>
<li>使用外部有更多特性的 Dockerfile 实现</li>
<li>避免其他 api 的副作用（中间镜像和容器）</li>
<li>优先考虑构建缓存来自动修剪</li>
</ul>
<p>为了使用 BuildKit 后端，你需要在 cli 中设置环境变量 <code>DOCKER_BUILDKET=1</code>，在你执行 <code>docker build</code> 之前。</p>
<p>学习基于 BuildKit 构建的实验性的 Dockerfile 语法，可以参考<a target="_blank" rel="noopener" href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md">文档</a>。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>下面是 <code>Dockerfile</code> 的格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>

<p>指令是大小写不敏感的。然而，把他们写成大写的话，更容易识别参数。</p>
<p>Docker 按序执行 <code>Dockerfile</code> 里的指令。一个 <code>Dockerfile</code> 文件 <strong>必须以 FROM 指令开头</strong> ，这个指令可能在 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#parser-directives">parser directives</a>、注释和其他全局<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#arg">参数</a>之后。 <code>FROM</code> 指令指定了你正在构建时用的<a target="_blank" rel="noopener" href="https://docs.docker.com/glossary/#parent_image">父镜像</a>。 <code>FROM</code> 也可能且仅可能后于一个或多个 <code>ARG</code> 指令，它是用于声明在 <code>FROM</code> 这一行中会使用到的参数。</p>
<p>Docker 将以 <code>#</code> 开头的作为注释，除非这一行是一个有效的<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#parser-directives">解析器指令</a>。一行中的其他位置的 <code>#</code> 标志被当做参数。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;we are running some # of cool things&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>评论行在指令执行前会被移除，意味着下面的例子中，注释不会被处理，下面两个例子是一样的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello \</span></span><br><span class="line"><span class="bash"><span class="comment"># comment</span></span></span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello \</span></span><br><span class="line"><span class="bash">world</span></span><br></pre></td></tr></table></figure>

<p>行连续字符（\） 在注释中不被支持。</p>
<blockquote>
<p>关于空格符<br/><br>为了向后兼容，在注释符和指令（比如 RUN）前面的空格会被忽略，但不建议这么使用。前置的空格在这些情况下也不会被保留。但是在指令参数中的空白符会被保留。下面的例子是一样的：</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"># this is a comment-line</span></span><br><span class="line">    <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is a comment-line</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure>

<h1 id="解析器指令"><a href="#解析器指令" class="headerlink" title="解析器指令"></a>解析器指令</h1><p>解析器指令是可选的，影响着接下来的行如何被处理。解析器指令不会添加 layer 到构建中，也不会作为一个构建阶段来展示。解析器指令使用一中注释的特殊形式：<code># directive=value</code>。一个单独的指令可能只会被使用一次。</p>
<p>一旦注释、空行或者构建指令被处理了，Docker 就不会再查找解析器指令了，而是把他们当做注释，不会再检查它们是否是有效的解析器指令。因此，所有解析器指令 <strong>必须</strong> 放在 <code>Dockerfile</code> 文件的最顶上。</p>
<p>解析器指令是大小写不敏感的。然而，按规定它们是小写的。规定也说明，在任何解析器指令后应该有一个空白行。行连续符（\）在指令中不生效。</p>
<p>由于这些规则，下面的例子是不合法的：<br>因为使用行连续符：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># direc \</span></span><br><span class="line">tive=value</span><br></pre></td></tr></table></figure>
<p>因为出现了两次：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directive=value1</span></span><br><span class="line"><span class="comment"># directive=value2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>因为在构建指令之后：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ImageName</span><br><span class="line"><span class="comment"># directive=value</span></span><br></pre></td></tr></table></figure>
<p>在一个注释之后，而被当做了注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># About my dockerfile</span></span><br><span class="line"><span class="comment"># directive=value</span></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>未知的指令同样被当做注释，除此之外，已知的指令由于出现在注释后，而被当做注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unknowndirective=value</span></span><br><span class="line"><span class="comment"># knowndirective=value</span></span><br></pre></td></tr></table></figure>
<p>在解析器指令中不允许使用换行符空格，因此下面的所有行都是一样的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#directive=value</span></span><br><span class="line"><span class="comment"># directive =value</span></span><br><span class="line"><span class="comment">#	directive= value</span></span><br><span class="line"><span class="comment"># directive = value</span></span><br><span class="line"><span class="comment">#	  dIrEcTiVe=value</span></span><br></pre></td></tr></table></figure>
<p>下面的解析器指令是被支持的：</p>
<ul>
<li>syntax</li>
<li>escape</li>
</ul>
<h1 id="syntax"><a href="#syntax" class="headerlink" title="syntax"></a>syntax</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=[remote image reference]</span></span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="comment"># syntax=docker.io/docker/dockerfile:1</span></span><br><span class="line"><span class="comment"># syntax=example.com/user/repo:tag@sha256:abcdef...</span></span><br></pre></td></tr></table></figure>

<p>仅当使用 BuildKit 后端时才可用该特性，使用传统构建后端时会被忽略。</p>
<p>syntax 指令定义用于构建 Dockerfile 文件的 Dockerfile 语法的位置。BuildKit 后端允许无缝使用被分发为 Docker 镜像的外部实现，并在容器沙箱内部环境执行。</p>
<p>自定义 Dockerfile 实现，能让你：</p>
<ul>
<li>自动获取 bugfixes 而不用更新 Docker daemon</li>
<li>确保所有用户使用相同的实现去构建你的 Dockerfile</li>
<li>使用最新的特性，而不用更新 Docker daemon</li>
<li>在新特定或者第三方特性集成进 Docker daemon 之前体验到</li>
<li>使用<a target="_blank" rel="noopener" href="https://github.com/moby/buildkit#exploring-llb">替换的构建定义，或者创建你自己的</a></li>
</ul>
<h2 id="官方发布（略）"><a href="#官方发布（略）" class="headerlink" title="官方发布（略）"></a>官方发布（略）</h2><h1 id="escape（略）"><a href="#escape（略）" class="headerlink" title="escape（略）"></a>escape（略）</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=\ (backslash)</span></span><br><span class="line">or</span><br><span class="line"><span class="comment"># escape=` (backtick)</span></span><br></pre></td></tr></table></figure>
<p><code>escape</code> 指令设置了 Dockerfile 里的转义符。默认为：\。</p>
<h1 id="环境变量替换"><a href="#环境变量替换" class="headerlink" title="环境变量替换"></a>环境变量替换</h1><p>环境变量（由 <code>ENV</code> 声明的）能够在一些指令中被使用。转义也可以通过在字面上将类似变量的语法包含到语句中来进行处理。</p>
<p>环境变量在 Dockerfile 中被声明为：<code>$&#123;variable_name&#125;</code> 或者 <code>$variable_name</code>。</p>
<p><code>$&#123;variable_name&#125;</code> 语法也支持一些标准的 <code>bash</code> 修改符，如下：</p>
<ul>
<li>${variable:-word}：判断<code>variable</code> 是否被设置，如果被设置，该值就是返回结构；如果没有被设置，<code>word</code> 就是返回结果；</li>
<li>${variable:+word}：判断<code>variable</code> 是否被设置，如果被设置，<code>word</code> 就是返回结果；否则，返回空字符串</li>
</ul>
<p>在所有场景中， <code>word</code> 可以是任何字符串，包括环境变量。</p>
<p>转义符可能在变量前，\$foo or \${foo}，这样就会被转义为字符串自变量 $foo、${foo}。</p>
<p>例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENV</span> FOO=/bar</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;FOO&#125;</span>   <span class="comment"># WORKDIR /bar</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . <span class="variable">$FOO</span>       <span class="comment"># ADD . /bar</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> \<span class="variable">$FOO</span> /quux <span class="comment"># COPY $FOO /quux</span></span></span><br></pre></td></tr></table></figure>

<p>环境变量被以下指令所支持：</p>
<ul>
<li>ADD</li>
<li>COPY</li>
<li>ENV</li>
<li>EXPOSE</li>
<li>FROM</li>
<li>LABEL</li>
<li>STOPSIGNAL</li>
<li>USER</li>
<li>VOLUME</li>
<li>WORKDIR</li>
<li>ONBUILD (当与上面支持的指令组合时)</li>
</ul>
<p>在整条指令中，环境变量替换会使用相同的值，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc</span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc</span><br></pre></td></tr></table></figure>
<p><code>def</code> 会是 <code>hello</code>，而不是 <code>bye</code>，然后， <code>ghi</code> 的值是 <code>bye</code>，因为它在上一行赋值之外。</p>
<h1 id="dockerignore-文件（略）"><a href="#dockerignore-文件（略）" class="headerlink" title=".dockerignore 文件（略）"></a>.dockerignore 文件（略）</h1><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a></p>
<h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line">or</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line">or</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p><code>FROM</code> 指令初始化一个新的构建阶段，并且为接下来的指令设置基础镜像。如此，一个有效的 Dockerfile 文件必须以 <code>FROM</code> 指令开始。镜像可以是任意有效的镜像，特别简单的开始是从公共仓库拉一个镜像。</p>
<ul>
<li><code>ARG</code> 是唯一能够在 <code>FROM</code> 之前的指令。见下方。</li>
<li><code>FROM</code> 可以在一个 Dockerfile 中出现多次，创建多个镜像或者使用一个构建阶段作为其他构建阶段的依赖。在每个新的<code>FROM</code>指令前，会简单的输出最后一个镜像 ID 到控制台上。每一个<code>FROM</code>指令会清除上一个指令产生的所有状态。</li>
<li>可选的 name 通过 <code>AS name</code>  添加到 <code>FROM</code> 的末尾，别名为一个新的构建阶段。这个别名可以在接下来的 <code>FROM</code> 和 <code>COPY --from=&lt;name&gt;</code> 指令中使用。</li>
<li>tag 或者 digest 值是可选的。如果你或略他们，构建器会默认使用 <code>latest</code>作为 <code>tag</code>。如果不能找到这个 tag，会返回错误。</li>
</ul>
<p>可选的 <code>--platform</code> 标志可以用于指定<code>FROM</code> 索引了多个平台的镜像时，某个平台使用的镜像。比如：<code>linux/amd64</code>、<code>linux/arm64</code>、<code>windows/amd64</code>等。默认的，构建请求的目标平台会被使用。全局构建参数也能在这个标志位中使用，比如<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope">automatic platform ARGS</a> 允许你强制一个阶段来本地化构建平台（<code>--platform=$BUILDPLATFORM</code>），使用它在这个阶段来跨平台编译。</p>
<h2 id="理解-ARG-和-FROM-的交互"><a href="#理解-ARG-和-FROM-的交互" class="headerlink" title="理解 ARG 和 FROM 的交互"></a>理解 ARG 和 FROM 的交互</h2><p>FROM 指令支持由 FROM 指令之前的ARG 指令所声明的变量：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>

<p>FROM 之前的 ARG 声明在一次构建阶段之外，因此它不能在 <code>FROM</code> 指令之后的任何地方使用。为了使用一个 ARG 声明的默认值，需要使用一个 ARG 指令来声明它，接着便能在一次构建阶段中使用了：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>

<h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p><code>RUN</code> 有两种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code> (shell 格式，命令在一个 shell 中执行，linux 上 默认是 /bin/sh -c ，在 windows 上是 cmd /S /C )</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec 格式)</li>
</ul>
<p><code>RUN</code> 指令会在当前镜像的最顶层执行任何命令，然后再提交结果。提交的结果镜像会被下一步骤使用。</p>
<p>将 <code>RUN</code> 指令分层并且生成提交，符合 Docker 的核心概念：提交是廉价的，也能从镜像历史的任意一个点创建新的容器，有点像代码控制一样。</p>
<p><code>exec</code> 模式可以避免 shell 字符串混乱，执行 RUN 命令使用一个不包含具体 shell 可执行命令的基础镜像。</p>
<p>对于 shell 模式，默认的 shell 可以通过 <code>SHELL</code> 命令修改。</p>
<p>在 shell 模式中，你可以使用反斜线（\）来继续输入多行参数，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="string"><span class="bash">echo $HOME&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>与下面例子是等价的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; echo $HOME&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>为了使用不同的 shell 而不是 /bin/sh，使用 exec 模式，传入期望的 shell，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<br /><br>exec 模式会被解析为 JSON 数组，意味着你必须使用双引号（”）来包括参数。</p>
</blockquote>
<p>不像 shell 模式，exec 模式不会调起一个命令行 shell。这意味着没有普通的 shell 进程产生。比如：<code>RUN [&quot;echo&quot;, &quot;$HOME&quot;]</code> 不会进行 $HOME 变量替换。如果你想 shell 进程或者使用 shell 模式或者直接执行一个 shell，可以执行：<code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</code>。当使用 ecec 模式并且直接执行一个 shell 时，是 shell 在进行环境变量替换，而不是 Docker。</p>
<blockquote>
<p>注意<br /><br>在 JSON 的形式中，需要转义反斜线。比如：<code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code> 这会导致错误。正确的是：<code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code>。</p>
</blockquote>
<p>在下一次构建时，RUN 指令的缓存不会自动失效。指令的缓存，比如：<code>RUN apt-get dist-upgrade -y</code> 会在下次构建时重用。<code>RUN</code> 指令的缓存在使用 <code>--no-cache</code> 时会失效，比如：<code>docker build --no-cache</code>。</p>
<p>对于 RUN 的缓存可以被 <code>ADD</code>，<code>COPY</code>指令失效（文件改变）。</p>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD 指令有这三种格式：</p>
<ul>
<li>CMD [“executable”,”param1”,”param2”] (exec 模式，这是不错的模式)</li>
<li>CMD [“param1”,”param2”] (作为 <code>ENTRYPOINT</code>的默认参数)</li>
<li>CMD command param1 param2 (shell 模式)</li>
</ul>
<p>在一个 Dockerfile 中只能有一个 CMD 指令。如果你提供多个 CMD 指令，则只有最后一个会生效。</p>
<p><strong>CMD的主要目标是为执行一个容器提供默认内容</strong> 。包括一个可执行文件，也可以省略可执行文件，在这种情况下，你必须指定一个 <code>ENTRYPOINT</code> 指令。</p>
<p>如果 CMD 被当做给 ENTRYPOINT 提供默认参数，那么 CMD 和 ENTRYPOINT 都必须用 JSON 数组的格式。</p>
<blockquote>
<p>注意：<br/><br>exec 模式也被当做 JSON 数组解析，必须使用双引号包裹。</p>
</blockquote>
<p>不像 shell 模式，exec 模式不会调起一个 shell，这意味着没有shell 会产生。比如：CMD [“echo”, “$HOME”] 不会进行变量替换。如果你想生成一个 shell 进程，那么使用 shell 模式或者执行一个 shell 脚本，比如：<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用 exec 模式直接执行一个 shell 脚本时，shell 会进行环境变量替换，而不是 docker。</p>
<p>当使用 shell 或者 exec 格式时，CMD 指令指定了执行镜像时的命令。</p>
<p>如果你用 CMD 执行 shell 模式，那么 <command> 会以<code>/bin/sh -c</code> 形式执行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;This is a test.&quot;</span> | wc -</span></span><br></pre></td></tr></table></figure>

<p>如果你想在没有 shell 的环境下执行你的 <code>&lt;command&gt;</code>，你必须使用 JSON 数组的形式，然后给出可执行文件的完整路径。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/usr/bin/wc&quot;</span>,<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>如果你想容器每次都执行相同的可执行文件，你可以考虑使用 <code>ENTRYPOINT</code> 和 <code>CMD</code> 混合使用。参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#entrypoint">ENTRYPOINT</a>。</p>
<p>如果用户指定了 <code>docker run</code> 的参数，那么会直接覆盖 <code>CMD</code>。</p>
<blockquote>
<p>注意：<br /><br>不要混淆 RUN 和 CMD。RUN 是执行一个命令，然后提交结果；CMD 不会在构建阶段执行任何东西，只是为镜像指定了一个默认的命令。</p>
</blockquote>
<h1 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>LABEL 指令为镜像添加了元数据。一个 LABEL 是一个键值对。在 LABEL 中如果包含空格，需要使用双引号，如果有换行，需要使用反斜线。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;This text illustrates \</span></span></span><br><span class="line"><span class="string"><span class="bash">that label-values can span multiple lines.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>镜像可以有多个 LABEL。你可以在一行中指定多个标签。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">&quot;value1&quot;</span> multi.label2=<span class="string">&quot;value2&quot;</span> other=<span class="string">&quot;value3&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">&quot;value1&quot;</span> \</span></span><br><span class="line"><span class="bash">      multi.label2=<span class="string">&quot;value2&quot;</span> \</span></span><br><span class="line"><span class="bash">      other=<span class="string">&quot;value3&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>标签在基础或者父镜像中，也会被其他镜像继承。存在子镜像覆盖父镜像中同名的标签。</p>
<p>为了查看一个镜像的标签，可以使用 <code>docker image inspect</code> 命令。可以使用 <code>--format</code> 选项来展示这些标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect --format=<span class="string">&#x27;&#x27;</span> myimage</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;,</span><br><span class="line">  &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span><br><span class="line">  &quot;multi.label1&quot;: &quot;value1&quot;,</span><br><span class="line">  &quot;multi.label2&quot;: &quot;value2&quot;,</span><br><span class="line">  &quot;other&quot;: &quot;value3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<p>EXPOSE 指令表达了容器在运行时监听的具体网络端口。你可以指定监听 TCP 或者 UDP，默认是 TCP。</p>
<p>EXPOSE 指令不会真实的发布端口。它作为文档类型在构建镜像的人和运行镜像的人直接运行。为了实际的发布端口，需要在运行容器时，使用 <code>docker run -p</code> 来发布监听，同时可以映射一个或多个端口。或者使用 <code>-P</code> 来发布所有暴露的端口（使用 EXPOSE 暴露的所有端口），并且把他们映射到高端口上。</p>
<p>EXPOSE 默认是 TCP。你也可以选择 UDP：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>也能同时使用 TCP 和 UDP：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，如果你用 <code>docker run -P</code>，端口会为 TCP、UDP 各打开一次。记住，<code>-P</code> 会使用临时的高端口号，因为每次执行时都可能不同。</p>
<p>不管 EXPOSE 如何设置，你都可以通过 <code>docker run -p</code> 来覆盖它们：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 80:80/tcp -p 80:80/udp ...</span></span><br></pre></td></tr></table></figure>
<p>在主机系统上设置端口重定向，可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports"><code>-P</code></a>。<code>docker network</code> 命令支持为容器间的交流创建网络，而不必需要暴露端口，因为容器连接到这个网络后可以通过任意端口与其他网络中的容器交流。更详细的信息可以查看 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/userguide/networking/">network</a>。</p>
<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>ENV 指令可以设置关键变量，设置 <code>&lt;key&gt;</code> 为 <code>&lt;value&gt;</code>。这个将会对接下来的构建阶段的指令产生影响。如果添加了双引号，则它会被删除，如果你没转义它们的话。举例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_NAME=<span class="string">&quot;John Doe&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> MY_DOG=Rex\ The\ Dog</span><br><span class="line"><span class="keyword">ENV</span> MY_CAT=fluffy</span><br></pre></td></tr></table></figure>
<p>ENV 指令允许一次使用多个键值对，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_NAME=<span class="string">&quot;John Doe&quot;</span> MY_DOG=Rex\ The\ Dog \</span><br><span class="line">    MY_CAT=fluffy</span><br></pre></td></tr></table></figure>

<p>使用 ENV 设置的环境变量将会在该镜像创建的容器运行时一直存在。你可以用过 <code>docker inspect</code> 来查看这些值，也能够用 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code>来覆盖。</p>
<p>环境变量持续性可能导致一些不符合预期的副作用，比如，设置 <code>ENV DEBIAN_FRONTEND=noninteractive</code> 来改变 <code>apt-get</code> 的行为，也许会混淆你的镜像的用户。</p>
<p>如果一个环境变量只是在构建的时候才需要，而不是在最终的镜像里，那么可以通过一个命令行来设置：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; apt-get install -y ...</span></span><br></pre></td></tr></table></figure>

<p>或者使用 ARG，这个也不会在最终的镜像中存在：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>替换的语法：<br /><br>ENV 也允许使用另一中语法： <code>ENV &lt;key&gt; &lt;value&gt;</code>，但这种方式不支持在一个 ENV 语句中写多个键值对。</p>
</blockquote>
<h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><p>ADD 有两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>当路径包含空格时，只能使用后一种形式。</p>
<blockquote>
<p>注意：<br/><br><code>--chown</code> 只在构建 Linux 容器时生效，在 Windows 容器上不生效。</p>
</blockquote>
<p>ADD 指令从 <code>&lt;src&gt;</code> 拷贝文件、目录或者远程文件，添加到镜像的 <code>&lt;dist&gt;</code> 目录下。</p>
<p>可以指定多个 <code>&lt;src&gt;</code> 源，但是如果他们是文件或者目录的话，他们会被解析为相对于构建环境的路径。</p>
<p>每一个 <code>&lt;src&gt;</code> 可以包含通配符，会使用 Go’s filepath.Match 规则来匹配。</p>
<p>添加所有 hom 开头的文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/</span></span><br></pre></td></tr></table></figure>

<p>下面的例子中，<code>?</code> 代表了任意一个单字符：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;dest&gt;</code> 是一个绝对路径，或者是相对于 <code>WORKDIR</code> 的相对路径。下面的例子使用相对路径，添加 “test.txt” 到 <code>&lt;WORKDIR&gt;/relativeDir/</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> test.txt relativeDir/</span></span><br></pre></td></tr></table></figure>
<p>如果使用绝对路径的 <code>&lt;dest&gt;</code>，那么就是绝对路径，比如：<code>ADD test.txt /absoluteDir/</code></p>
<p>同时可以解压一些归档文件。</p>
<h1 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h1><p>是 ADD 的子集。不能解压归档文件。</p>
<h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p>ENTRYPOINT 有两种形式：<br>exec 模式，默认的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>shell 模式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>
<p>ENTRYPOINT 让你为容器配置一个可执行文件。</p>
<h2 id="exec-模式"><a href="#exec-模式" class="headerlink" title="exec 模式"></a>exec 模式</h2><h2 id="shell-模式"><a href="#shell-模式" class="headerlink" title="shell 模式"></a>shell 模式</h2><h2 id="CMD-与-ENTRYPOINT-交互"><a href="#CMD-与-ENTRYPOINT-交互" class="headerlink" title="CMD 与 ENTRYPOINT 交互"></a>CMD 与 ENTRYPOINT 交互</h2><h1 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h1><p><code>VOLUME [&quot;/data&quot;]</code></p>
<p>VOLUME 指令创建一个具名的挂载点，会被外部宿主掌控。可以是 JSON 数组，或者直接字符串。</p>
<p><code>docker run</code>命令会初始化最新创建的卷，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /myvol</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /myvol</span></span><br></pre></td></tr></table></figure>
<p>在执行 <code>docker run</code> 时会创建一个新的挂载点在 /myvol 上，并且会拷贝 <code>greeting</code> 到挂载点里。</p>
<h1 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>
<p>为接下来的执行指定用户。</p>
<h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><p>为 RUN、CMD、ENTRYPOINT、COPY、ADD 设置工作目录。如果该目录不存在，会自动创建该目录。</p>
<p>如果存在多个 WORKDIR 目录，则下一个目录会基于上一个目录而来：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p>最后的输出是：/a/b/c</p>
<p>能够使用 ENV 中定义的环境变量。</p>
<h1 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p>ARG 指令定义用户可以在构建阶段传递的变量，使用 <code>docker build --build-tab &lt;varname&gt;=&lt;value&gt;</code> 传递。如果使用了未定义的 arg 变量，会报错。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br><span class="line"><span class="keyword">ARG</span> buildno=<span class="number">1</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>定义 args。如果有则用，如果无，则用上面的默认值。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h1 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure>
<p>当将映像用作另一个构建的基础时，ONBUILD指令会在映像上添加一个触发指令，以便稍后执行。该触发器将在下游构建的上下文中执行，就像它已被插入到下游Dockerfile中的FROM指令之后一样。<br>任何构建指令都可以注册为触发器。</p>
<h1 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h1><p>有两种形式：</p>
<ul>
<li><code>HEALTHCHECK [OPTIONS] CMD command</code> (通过在容器里执行一个命令来检查))</li>
<li><code>HEALTHCHECK NONE</code> (禁用从基础镜像里继承来的检查)</li>
</ul>
<p>这些选项能在 CMD 之前出现：</p>
<ul>
<li>–interval=DURATION (default: 30s)</li>
<li>–timeout=DURATION (default: 30s)</li>
<li>–start-period=DURATION (default: 0s)</li>
<li>–retries=N (default: 3)</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/10/%E6%88%91%E8%83%BD%E7%94%A8Nodejs%E6%9D%A5%E5%81%9A%E5%90%8E%E7%AB%AF%E5%90%97/" rel="prev" title="我能用Nodejs来做后端吗?">
                  <i class="fa fa-chevron-left"></i> 我能用Nodejs来做后端吗?
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81MjY5OS8yOTE3Ng=="></div><script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谭智轩</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
